<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 通过 Sourcery 来写 API Client · Inti's Blog</title><meta name="description" content="通过 Sourcery 来写 API Client - Inti Guo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="search" type="application/opensearchdescription+xml" href="http://intii.com/atom.xml" title="Inti's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link shake"><img src="/Logo.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://twitter.com/int123c" target="_blank" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">通过 Sourcery 来写 API Client</h1><div class="post-info">Jun 25, 2018</div><div class="post-content"><p>我不太喜欢现在公司项目中 API Client 的实现方式，虽然并没有什么问题，但我还是忍不住要重构一下。原本的实现是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeModel</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)doSomething:(<span class="built_in">NSString</span> *)aParam completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> isSuccess, <span class="built_in">NSString</span> *errorMessage, SomeModel * someModel))completion &#123;</div><div class="line">    [APIClient.sharedClient </div><div class="line">        POST:someEndpoint</div><div class="line">        parameters: @&#123; <span class="string">@"p"</span>: aParam &#125;</div><div class="line">        success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line">            PPApiResponseObject *responseItem = [PPApiResponseObject createFrom:responseObject];</div><div class="line">            <span class="keyword">if</span> (responseItem.isSuccess) &#123;</div><div class="line">                <span class="comment">// do something</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// do something</span></div><div class="line">        &#125;</div><div class="line">        failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line">            <span class="comment">// do something</span></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里有几个地方是我不喜欢的：1. 用 Objective C 写的；2. API 不太现代；3. endpoint 分散在了不同的 model 定义里面；4. 重复的东西太多。</p>
<a id="more"></a>
<h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>这次重构我不想有太大的改动，所以 <code>[APIClient.sharedClient...]</code> 那部分我是会保留的，同时我也需要支持 Objective C，于是用 enum 来表示 endpoint 这种事情肯定是做不到的了。为了能好好利用自动补全，我还是会采用方法来实现每一个 endpoint，只是这次我们会把它们都放在一个类里，就叫作 <code>API</code> 吧。</p>
<p>事实上这些方法的实现都大同小异，这种情况就特别适合使用元编程了，我希望我能够以 declarative 的方式定义一个 endpoint，然后再通过 Sourcery 来自动生成代码。我希望这个定义是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">API</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ProductSearch</span>: <span class="title">APIEndPoint</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">let</span> endpoint = <span class="string">"/app/search"</span></div><div class="line">        </div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RequestBody</span> </span>&#123;</div><div class="line">            <span class="keyword">let</span> keyword: <span class="type">String</span></div><div class="line">            <span class="keyword">let</span> page: <span class="type">Int</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ResponseBody</span>: <span class="title">ResponseBodyType</span> </span>&#123;</div><div class="line">            <span class="keyword">let</span> totalCount: <span class="type">Int</span></div><div class="line">            <span class="keyword">let</span> products: [<span class="type">Product</span>]; <span class="class"><span class="keyword">struct</span> <span class="title">Product</span>: <span class="title">ResponseBodyType</span> </span>&#123;</div><div class="line">                <span class="keyword">let</span> productId: <span class="type">Int</span></div><div class="line">                <span class="keyword">let</span> productName: <span class="type">String</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就和我们的 API 文档一模一样，<code>APIEndPoint</code> 是一个 protocol，一方面可以指导我定义一个 endpoint，另一方面，可以告诉 Sourcery 我们都有哪一些 endpoint 需要生成代码。实现 <code>ResponseBodyType</code> 的类型需要同时实现 <code>Codable</code>，这样我们就能将 JSON 转化为 Model 了。这同时也能够告诉 Sourcery，有哪一些类型我们需要提供一个 Objective C 可以理解的版本，毕竟无论是嵌套类型还是 struct，Objective C 都是不认的。</p>
<p>我决定用一个 class 把它包住。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">API_ProductSearch_ResponseBody</span>: <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> body: <span class="type">API</span>.<span class="type">ProductSearch</span>.<span class="type">ResponseBody</span></div><div class="line">    <span class="keyword">init</span>(body: <span class="type">API</span>.<span class="type">ProductSearch</span>.<span class="type">ResponseBody</span>) &#123; <span class="keyword">self</span>.body = body &#125;</div><div class="line"></div><div class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> totalCount: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> body.totalCount</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> product: [<span class="type">API_ProductSearch_ResponseBody_Product</span>] &#123;</div><div class="line">        <span class="keyword">return</span> body.product.<span class="built_in">map</span>(<span class="type">API_ProductSearch_ResponseBody_Product</span>.<span class="keyword">init</span>(body:))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现部分，我希望和原本差不多，但 completion handler 的参数是一个 <code>enum Result&lt;Body&gt;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">productSearch</span><span class="params">(</div><div class="line">    keyword: String,</div><div class="line">    page: Int,</div><div class="line">    <span class="number">_</span> completion: @escaping <span class="params">(Result&lt;API.ProductSearch.ResponseBody&gt;)</span></span></span>-&gt;<span class="type">Void</span> = &#123;<span class="number">_</span> <span class="keyword">in</span>&#125;) -&gt; <span class="type">URLSessionDataTask</span>? &#123;</div><div class="line">    <span class="comment">// prepare paramenter dictionary</span></div><div class="line">    <span class="keyword">return</span> <span class="type">APIClient</span>.sharedClient().post(<span class="type">API</span>.<span class="type">ProductSearch</span>.endpoint, </div><div class="line">            parameters: param,</div><div class="line">            success:&#123; task, responseObject <span class="keyword">in</span></div><div class="line">                <span class="comment">// do something</span></div><div class="line">            &#125;, failure:&#123; task, error <span class="keyword">in</span></div><div class="line">                <span class="comment">// do something</span></div><div class="line">            &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当然还需要一个 Objective C 的版本，自然也就不能用 <code>Result</code> 了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">post_productSearch</span><span class="params">(</div><div class="line">    keyword: String,</div><div class="line">    page: Int,</div><div class="line">    <span class="number">_</span> completion: @escaping <span class="params">(API_ProductSearch_ResponseBody?, NSError?)</span></span></span>-&gt;<span class="type">Void</span> = &#123;<span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span>&#125;) -&gt; <span class="type">URLSessionDataTask</span>?</div></pre></td></tr></table></figure>
<p>既然大致的方向决定了，接下来就是写模板了。</p>
<h2 id="写模板"><a href="#写模板" class="headerlink" title="写模板"></a>写模板</h2><p><span style="color: #680000">❖ 因为 Hexo 会尝试去解析 stencil 模板，所以文章中用 {٪ 来防止解析发生。</span></p>
<h3 id="适配-Objective-C"><a href="#适配-Objective-C" class="headerlink" title="适配 Objective C"></a>适配 Objective C</h3><p>写这个部分的模板还是比较烦人的，因为 Objective C 并不支持 Swift 里面的所有类型。</p>
<p>首先是提供 Objective C 可以理解的 response body。就像之前所说的那样，我们只需要让一个 class 把每一个实现 <code>ResponseBodyType</code> 的类型包起来就行了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;٪<span class="keyword">for</span> responseBody <span class="keyword">in</span> types.all <span class="keyword">where</span> responseBody.implements.<span class="type">ResponseBodyType</span>%&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> </span>&#123;&#123;responseBody.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125;: <span class="type">NSObject</span> &#123;</div><div class="line">    <span class="keyword">let</span> body: &#123;&#123;responseBody.name&#125;&#125;</div><div class="line">    <span class="keyword">init</span>(body: &#123;&#123;responseBody.name&#125;&#125;) &#123; <span class="keyword">self</span>.body = body &#125;</div><div class="line">    &#123;٪<span class="keyword">for</span> variable <span class="keyword">in</span> responseBody.variables%&#125;</div><div class="line">    <span class="comment">// variables</span></div><div class="line">    &#123;٪endfor%&#125;</div><div class="line">&#123;٪endfor%&#125;</div></pre></td></tr></table></figure>
<p>Stencil 提供了一些内置的 filter，所以我们能够很简单地将一些嵌套类型的名称 <code>A.B.C</code> 转变成 <code>A_B_C</code>。Variable 部分需要比较注意的是，像 <code>Int?</code> 这种东西  Objective C 也是看不懂的，需要额外处理成 <code>NSNumber</code>，当 variable 是 <code>ResponseBodyType</code> 或 <code>[ResponseBodyType]</code> 或 <code>ResponseBodyType?</code> 之类的也需要额外处理，挺啰嗦的，这里就不一一写明了。Sourcery 中 <code>Variable</code> 有两个参数 <code>type</code> 和 <code>typeName</code>，说实话很诡异，必须得好好看文档才知道什么时候该用什么。</p>
<p>对 <code>ResponseBodyType?</code> 这种情况目前还没有很好的解决方法， <code>typeName.unwrappedTypeName</code> 返回的是 <code>String</code> 而不是 <code>TypeName</code>，正巧我把这些类型都嵌套在 <code>API</code> 里，可以判断其 <code>actualTypeName</code> 的前缀来捕获这种情况。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;٪<span class="keyword">if</span> variable.typeName.isOptional and variable.typeName.actualTypeName|hasPrefix:<span class="string">"API."</span> %&#125;</div><div class="line"><span class="meta">@objc</span> <span class="keyword">var</span> &#123;&#123;variable.name&#125;&#125;: &#123;&#123;variable.typeName.actualTypeName.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125; &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> v = body.&#123;&#123;variable.name&#125;&#125; &#123;</div><div class="line">        <span class="keyword">return</span> &#123;&#123;variable.type.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125;(body: v)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line">&#123;٪endif%&#125;</div></pre></td></tr></table></figure>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>提供 Objective C 版本的请求方法很简单，就是内部调用 Swift 版本的方法。这部分需要注意的只有一些 optional 的参数类型可能要用别的类型替换，就一笔带过了。</p>
<p>有了上一个小节的经验，我们可以发现这些模板的写法都大同小异。对方法签名的参数生成和请求参数的生成，无非都是遍历 <code>RequestBody</code> 的 <code>variables</code> 而已。唯一值得一提的是，我们可以用 <code>{٪if var.variables.count == 0%}</code> 来判断一个数组是否为空，还可以通过 <code>{٪if forloop.last%}</code> 来判断是否是当前循环的最后一次。很多用法其实都没有写在 Sourcery 的文档里面，不妨也去看看 Stencil 的文档。</p>
<h3 id="Coding-Keys"><a href="#Coding-Keys" class="headerlink" title="Coding Keys"></a>Coding Keys</h3><p>有时候我们希望不用去刻意地让属性的名称和 JSON 里的 key 完全对应上，因为有的 key 的命名真的是难以理解，这时我们也可以利用 Sourcery 帮助我们自动生成相关的代码。</p>
<p><a href="https://intii.com/2017/codable-enum-with-associated-values/%60">和我之前的文章一样</a>，我们用 <code>AutoCodable</code> 来指定这些需要生成代码的类型，但幸运的是，我们没有必要和 Enum with Associated Value 做斗争了。</p>
<p>仔细观察了一下，我大概有这么几个需求：</p>
<ol>
<li>类型为数组时，默认值为 <code>[]</code></li>
<li>可以指定默认值 <code>defaultValue = 0</code></li>
<li>可以指定 key <code>jsonKey = &quot;abc&quot;</code></li>
<li>某一些情况将 <code>Int</code> 转为 <code>Bool</code></li>
</ol>
<p>对于数组默认值，我们只需要把对应情况的 <code>decode</code> 改成 <code>decodeIfPresent ?? []</code> 就好了。</p>
<p>后三者则用到了 Sourcery 中的 annotation 功能，通过注释给 Sourcery 传递代码以外的信息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sourcery: jsonKey = "id"</span></div><div class="line"><span class="comment">// sourcery: defaultValue = 0</span></div><div class="line"><span class="keyword">let</span> productId: <span class="type">Int</span></div><div class="line"><span class="comment">// sourcery: boolFromInt</span></div><div class="line"><span class="keyword">let</span> worthBuying: <span class="type">Bool</span></div></pre></td></tr></table></figure>
<p>模板中可以通过 <code>annotated</code> 这个 filter 来判断目标是否有相应的注释。也可以通过 <code>something.annotation.jsonKey</code> 这种方式来获取注释的值。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>元编程的一个好处就是没有复杂的设计，这使得扩展变得很容易。比如说，我们可以给 endpoint 增加一个获取 mock response 的功能。我们通过判断 endpoint 是否实现某一个 protocol 来决定是否插入代码。</p>
<p>对于这个扩展，endpoint 需要实现 <code>APIEndPointHasFakeResponse</code> 这个 protocol：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">APIEndPointHasFakeResponse</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">handleRequestWithMockResponse</span><span class="params">(<span class="number">_</span> param: [String: Any]?, completionHandler: <span class="params">(Result&lt;Data&gt;)</span></span></span>-&gt;<span class="type">Void</span>) -&gt; <span class="type">Bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，我们既可以直接返回一段 JSON，也可以将请求转发给 mock server 来获取一段 mock response。当然我们也可以只对特定的请求做处理，并在这种情况下返回 <code>false</code>。</p>
<p>我们完全不用担心这些多余的扩展会污染我们的代码，毕竟这些代码只有在实现了协议的情况下才会插入到请求方法当中；我们也可以在 extension 中实现这个协议，以保持 endpoint 定义的纯洁性，当我们不需要 mock response 了，只需要随手删掉相关代码就可以了。</p>
<p>我们也可以只移除 protocol 而保留方法的实现，以方便下一次使用。</p>
<p>我们可以把这一部分写成一个 macro：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;٪macro extensionFakeResponse type requestBody%&#125;</div><div class="line">&#123;٪<span class="keyword">if</span> type.implements.<span class="type">APIEndPointHasFakeResponse</span>%&#125;</div><div class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></div><div class="line">        <span class="keyword">if</span> &#123;&#123;type.name&#125;&#125;.handleRequestWithMockResponse(&#123;٪call paramOrNil requestBody-%&#125;, completionHandler: &#123; </div><div class="line">            <span class="keyword">switch</span> $<span class="number">0</span> &#123;</div><div class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .success(json):</div><div class="line">                <span class="keyword">let</span> result = <span class="keyword">try</span>! <span class="type">JSONDecoder</span>().decode(<span class="type">APIResponse</span>&lt;&#123;&#123;type.name&#125;&#125;.<span class="type">ResponseBody</span>&gt;.<span class="keyword">self</span>, from: json!)</div><div class="line">                completion(.success(result.body))</div><div class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .failure(error): completion(.failure(error))</div><div class="line">            &#125;</div><div class="line">        &#125;) &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">#endif</div><div class="line">&#123;٪endif%&#125;</div><div class="line">&#123;٪endmacro%&#125;</div></pre></td></tr></table></figure>
<p>这样就能尽可能使请求方法模板看起来更干净一些。尽管生成的代码是挺丑的，不过谁要去管它们呢。</p>
<p>很遗憾 Sourcery 好像还并不支持 <code>indent</code> 这个 filter，所以当缩进有点深的时候，模板会变得很难看（尽管官方好像说是支持的）。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/refactoring-others-project-001/" class="next">Next Post →</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'Mon Jun 25 2018 11:21:00 GMT+0800',
  owner: 'int123c',
  repo: 'int123c.github.io',
  oauth: {
    client_id: 'efccd5f0aa425a6453e4',
    client_secret: 'd886480b3ac601b49591d7d457cafaeefbe546c1',
  },
})
gitment.render('container')

</script><div class="copyright"><p>© 2012 - 2018, handcrafted under ☁︎ in the city of knockoffs.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create',"UA-17603222-1",'auto');ga('send','pageview');</script></body></html>