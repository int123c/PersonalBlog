<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Intii</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://intii.com/"/>
  <updated>2018-11-25T14:37:26.485Z</updated>
  <id>http://intii.com/</id>
  
  <author>
    <name>Shangxin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Optional Tuple 和 Function</title>
    <link href="http://intii.com/2018/flatmapping-optional-tuple-with-function/"/>
    <id>http://intii.com/2018/flatmapping-optional-tuple-with-function/</id>
    <published>2018-11-25T01:21:00.000Z</published>
    <updated>2018-11-25T14:37:26.485Z</updated>
    
    <content type="html"><![CDATA[<p>见到 optional 的东西时我都会有种莫名的舒爽，因为我可以用 <code>map</code> 或者 <code>flatMap</code> 将它作为参数传给某个函数，并将结果又以同样的方式传递给下一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newImage = imageThatIsOptional</span><br><span class="line">    .<span class="built_in">map</span>(scale)</span><br><span class="line">    .<span class="built_in">map</span>(rotate)</span><br></pre></td></tr></table></figure><p>但偶尔我们会碰到一些拥有多个参数的函数，比如说 <code>crop(_ image: UIImage, with rect: CGRect)</code>，这时链式调用就尴尬了。</p><a id="more"></a><p>曾几何时，我们是可以把 tuple 直接作为多参数函数的参数的，那个时候我们可以写成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple = (image, .zero)</span><br><span class="line">crop(tuple) <span class="comment">// now it would be error: missing argument for parameter 'with' in call</span></span><br></pre></td></tr></table></figure><p>后来 Swift 取消了这个功能，我们不能再直接将 tuple 作为参数了。但是，我们依然能够通过 <code>map</code> 的方式，将一个 optional 的 tuple 作为参数传给函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: (<span class="type">UIImage</span>, <span class="type">CGRect</span>)? = (image, <span class="type">CGRect</span>.zero)</span><br><span class="line">tuple.<span class="built_in">map</span>(crop)</span><br></pre></td></tr></table></figure><p>很棒吧，但我们还需要解决一个问题，那就是怎么优雅地创建这个 tuple。<a href="https://twitter.com/johnsundell/status/1066012565615071233">John Sundell 给我们推荐了一个方法</a>——再给 <code>Optional</code> 加个 <code>flatMap</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(with expression: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">T</span>?) -&gt; (<span class="type">Wrapped</span>, <span class="type">T</span>)? &#123;</span><br><span class="line">        <span class="keyword">return</span> flatMap &#123; a <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> expression().<span class="built_in">map</span> &#123; b <span class="keyword">in</span> <span class="keyword">return</span> (a, b) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newImage1 = image.<span class="built_in">map</span>(scale).flatMap(with: <span class="type">CGRect</span>.zero).<span class="built_in">map</span>(crop)</span><br><span class="line"><span class="comment">// 当值不是 optional 的时候，我们也可以强行让它变成 optional</span></span><br><span class="line"><span class="keyword">let</span> newImage2 = <span class="type">Optional</span>(<span class="type">UIImage</span>()).flatMap(with: <span class="type">CGRect</span>.zero).<span class="built_in">map</span>(crop)</span><br></pre></td></tr></table></figure><p>当然我们也可以从方法下手，用 <a href="https://github.com/pointfreeco/swift-overture">swift-overture</a> 这种东西把 <code>crop</code> 变成只需要一个参数的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;见到 optional 的东西时我都会有种莫名的舒爽，因为我可以用 &lt;code&gt;map&lt;/code&gt; 或者 &lt;code&gt;flatMap&lt;/code&gt; 将它作为参数传给某个函数，并将结果又以同样的方式传递给下一个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; newImage = imageThatIsOptional&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(scale)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(rotate)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但偶尔我们会碰到一些拥有多个参数的函数，比如说 &lt;code&gt;crop(_ image: UIImage, with rect: CGRect)&lt;/code&gt;，这时链式调用就尴尬了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Optional" scheme="http://intii.com/tags/Optional/"/>
    
      <category term="Tuple" scheme="http://intii.com/tags/Tuple/"/>
    
      <category term="flatMap" scheme="http://intii.com/tags/flatMap/"/>
    
      <category term="Monad" scheme="http://intii.com/tags/Monad/"/>
    
      <category term="Function" scheme="http://intii.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>新头像，史莱姆</title>
    <link href="http://intii.com/2018/new-avatar-slime-not-evil/"/>
    <id>http://intii.com/2018/new-avatar-slime-not-evil/</id>
    <published>2018-11-07T11:21:31.000Z</published>
    <updated>2018-11-25T14:34:08.967Z</updated>
    
    <content type="html"><![CDATA[<p>本季最喜欢的动画大概就是转生变成史莱姆了吧，实在是太可爱了，看了第一集就决定新头像是史莱姆了，但拖延了一个月才画（<br><a id="more"></a><br><img src="/media/slime-not-evil.PNG" alt="slime-not-evil"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本季最喜欢的动画大概就是转生变成史莱姆了吧，实在是太可爱了，看了第一集就决定新头像是史莱姆了，但拖延了一个月才画（&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写一个 Mock API Server 让生活更简单</title>
    <link href="http://intii.com/2018/make-life-easier-with-mock-api-server/"/>
    <id>http://intii.com/2018/make-life-easier-with-mock-api-server/</id>
    <published>2018-08-18T03:21:00.000Z</published>
    <updated>2018-11-12T05:24:05.540Z</updated>
    
    <content type="html"><![CDATA[<p>公司项目的业务逻辑蛮复杂的，有时候我们需要测试 UI，就得让订单达到某一个特定的状态，往往需要在后台里先点个几分钟。其实最后我们还不是拿的后端返回的数据来填充 UI，所以为什么不直接把这个状态的数据构造好，直接拿来使用呢？所以我还是决定写个 Mock Server。</p><p>Mock Server 的功能很简单：</p><ol><li>根据 API Endpoint，返回配置文件中指定的 JSON 文件；</li><li>可以局部匹配参数，返回指定的 JSON 文件。</li></ol><p>后来 Android 端的小伙伴似乎也有点兴趣，但不想总是改代码指向 Mock Server，那行，我们就再加一个功能：<strong>3. 配置文件中没有指定的接口的请求，转发到开发服务器中。</strong></p><a id="more"></a><p>前两部分很简单，就是写一个 API Server 而已。因为懒得碰其它语言，直接使用了 Swift + Vapor。每次收到请求，我们都读取一下配置文件，大概是这么个结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pref</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> endpoints: [<span class="type">Endpoint</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Endpoint</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> endpoint: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> filename: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dispatch: [<span class="type">Dispatcher</span>]?</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dispatcher</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> parameters: <span class="type">JSONValue</span></span><br><span class="line">        <span class="keyword">let</span> filename: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">match</span><span class="params">(<span class="number">_</span> param: JSONValue)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parameters.compare(param)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得请求后，我们首先判断接口是否在 <code>Pref.endpoints</code> 中，如果有，则在看其参数是否存在一个子集处于 <code>Endpoint.dispatch</code> 中，如果有则使用其中的 <code>filename</code>.json，没有则 Fallback 到 <code>Endpoint.filename</code>.json。</p><p>对于其它的一切情况，返回 404。</p><p>第三点就比较麻烦了，一开始我想在 Mock Server 里再发一次请求，尽管咨询了后端的同学，但最终还是遇到了一些我暂时解决不了的问题：</p><ol><li>多个请求同时来的时候会收不到一些响应；</li><li>用 Nginx 实现 HTTPS 的时候，响应会变成双倍。但 Vapor 3 直接实现 HTTPS，找遍了 Google 都没找到方法。</li></ol><p>我倒腾了很久都没搞懂是什么情况……最后 Google 发现 Nginx 有一个东西叫做 <code>proxy_next_upstream</code>，我们可以指定多个 Upstream，如果一个有问题，就用下一个。所以我们可以写下这样的 Upstream：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> w &#123;</span><br><span class="line">    <span class="attribute">server</span> localhost:4343 max_fails=0 weight=200;</span><br><span class="line">    <span class="attribute">server</span> real.dev.api.server.com:443 max_fails=0 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是要写下权重，避免 Nginx 轮询调用。</p><p>然后再写两个 Server：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server</span> &#123; #A</span><br><span class="line">    <span class="attribute"><span class="nomarkup">listen</span></span>       80;</span><br><span class="line">    <span class="attribute"><span class="nomarkup">listen</span></span>       443 ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  real.dev.api.server.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> servernew.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span>    shared:SSL:1m;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  5m;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> https://w;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host real.dev.api.server.com;</span><br><span class="line">        <span class="attribute">proxy_next_upstream</span> error timeout http_500 http_502 http_503 http_504 http_404 invalid_header non_idempotent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> &#123; #B</span><br><span class="line">    <span class="attribute"><span class="nomarkup">listen</span></span>       4343 ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> servernew.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:9090;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host real.dev.api.server.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，通过改 Host 或改代码指向本机 IP 的方式，我们就能通过 Server#A 先调用 Mock Server，如果配置文件中没有请求的接口，则返回 404，接着调用真实的开发环境接口。</p><p>Server#B 是因为 Server#A 的 <code>proxy_pass</code> 用的是 <code>https</code>，试了一下有问题，所以又做了一层。我并不清楚以上哪一行是多余的，反正能用（</p><p>现在我们就能无痛使用 Mock Server 获得假数据了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司项目的业务逻辑蛮复杂的，有时候我们需要测试 UI，就得让订单达到某一个特定的状态，往往需要在后台里先点个几分钟。其实最后我们还不是拿的后端返回的数据来填充 UI，所以为什么不直接把这个状态的数据构造好，直接拿来使用呢？所以我还是决定写个 Mock Server。&lt;/p&gt;
&lt;p&gt;Mock Server 的功能很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 API Endpoint，返回配置文件中指定的 JSON 文件；&lt;/li&gt;
&lt;li&gt;可以局部匹配参数，返回指定的 JSON 文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后来 Android 端的小伙伴似乎也有点兴趣，但不想总是改代码指向 Mock Server，那行，我们就再加一个功能：&lt;strong&gt;3. 配置文件中没有指定的接口的请求，转发到开发服务器中。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Vapor" scheme="http://intii.com/tags/Vapor/"/>
    
      <category term="Nginx" scheme="http://intii.com/tags/Nginx/"/>
    
      <category term="API Server" scheme="http://intii.com/tags/API-Server/"/>
    
  </entry>
  
  <entry>
    <title>通过 Sourcery 来写 API Client</title>
    <link href="http://intii.com/2018/write-api-client-with-sourcery/"/>
    <id>http://intii.com/2018/write-api-client-with-sourcery/</id>
    <published>2018-06-25T03:21:00.000Z</published>
    <updated>2018-11-29T14:46:55.522Z</updated>
    
    <content type="html"><![CDATA[<p>我不太喜欢现在公司项目中 API Client 的实现方式，虽然并没有什么问题，但我还是忍不住要重构一下。原本的实现是这样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeModel</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)doSomething:(<span class="built_in">NSString</span> *)aParam completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> isSuccess, <span class="built_in">NSString</span> *errorMessage, SomeModel * someModel))completion &#123;</span><br><span class="line">    [APIClient.sharedClient </span><br><span class="line">        POST:someEndpoint</span><br><span class="line">        parameters: @&#123; <span class="string">@"p"</span>: aParam &#125;</span><br><span class="line">        success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">            PPApiResponseObject *responseItem = [PPApiResponseObject createFrom:responseObject];</span><br><span class="line">            <span class="keyword">if</span> (responseItem.isSuccess) &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里有几个地方是我不喜欢的：1. 用 Objective C 写的；2. API 不太现代；3. endpoint 分散在了不同的 model 定义里面；4. 重复的东西太多。</p><a id="more"></a><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>这次重构我不想有太大的改动，所以 <code>[APIClient.sharedClient...]</code> 那部分我是会保留的，同时我也需要支持 Objective C，于是用 enum 来表示 endpoint 这种事情肯定是做不到的了。为了能好好利用自动补全，我还是会采用方法来实现每一个 endpoint，只是这次我们会把它们都放在一个类里，就叫作 <code>API</code> 吧。</p><p>事实上这些方法的实现都大同小异，这种情况就特别适合使用元编程了，我希望我能够以 declarative 的方式定义一个 endpoint，然后再通过 Sourcery 来自动生成代码。我希望这个定义是这个样子的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ProductSearch</span>: <span class="title">APIEndPoint</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> endpoint = <span class="string">"/app/search"</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RequestBody</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> keyword: <span class="type">String</span></span><br><span class="line">            <span class="keyword">let</span> page: <span class="type">Int</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ResponseBody</span>: <span class="title">ResponseBodyType</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> totalCount: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">let</span> products: [<span class="type">Product</span>]; <span class="class"><span class="keyword">struct</span> <span class="title">Product</span>: <span class="title">ResponseBodyType</span> </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> productId: <span class="type">Int</span></span><br><span class="line">                <span class="keyword">let</span> productName: <span class="type">String</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就和我们的 API 文档一模一样，<code>APIEndPoint</code> 是一个 protocol，一方面可以指导我定义一个 endpoint，另一方面，可以告诉 Sourcery 我们都有哪一些 endpoint 需要生成代码。实现 <code>ResponseBodyType</code> 的类型需要同时实现 <code>Codable</code>，这样我们就能将 JSON 转化为 Model 了。这同时也能够告诉 Sourcery，有哪一些类型我们需要提供一个 Objective C 可以理解的版本，毕竟无论是嵌套类型还是 struct，Objective C 都是不认的。</p><p>我决定用一个 class 把它包住。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API_ProductSearch_ResponseBody</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">API</span>.<span class="type">ProductSearch</span>.<span class="type">ResponseBody</span></span><br><span class="line">    <span class="keyword">init</span>(body: <span class="type">API</span>.<span class="type">ProductSearch</span>.<span class="type">ResponseBody</span>) &#123; <span class="keyword">self</span>.body = body &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> totalCount: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body.totalCount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> product: [<span class="type">API_ProductSearch_ResponseBody_Product</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> body.product.<span class="built_in">map</span>(<span class="type">API_ProductSearch_ResponseBody_Product</span>.<span class="keyword">init</span>(body:))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现部分，我希望和原本差不多，但 completion handler 的参数是一个 <code>enum Result&lt;Body&gt;</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">productSearch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keyword: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    page: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> completion: @escaping <span class="params">(Result&lt;API.ProductSearch.ResponseBody&gt;)</span></span></span>-&gt;<span class="type">Void</span> = &#123;<span class="number">_</span> <span class="keyword">in</span>&#125;) -&gt; <span class="type">URLSessionDataTask</span>? &#123;</span><br><span class="line">    <span class="comment">// prepare parameter dictionary</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">APIClient</span>.sharedClient().post(<span class="type">API</span>.<span class="type">ProductSearch</span>.endpoint, </span><br><span class="line">            parameters: param,</span><br><span class="line">            success:&#123; task, responseObject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;, failure:&#123; task, error <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然还需要一个 Objective C 的版本，自然也就不能用 <code>Result</code> 了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">post_productSearch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keyword: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    page: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> completion: @escaping <span class="params">(API_ProductSearch_ResponseBody?, NSError?)</span></span></span>-&gt;<span class="type">Void</span> = &#123;<span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span>&#125;) -&gt; <span class="type">URLSessionDataTask</span>?</span><br></pre></td></tr></table></figure><p>既然大致的方向决定了，接下来就是写模板了。</p><h2 id="写模板"><a href="#写模板" class="headerlink" title="写模板"></a>写模板</h2><p><span style="color: #680000">❖ 因为 Hexo 会尝试去解析 stencil 模板，所以文章中用 {٪ 来防止解析发生。</span></p><h3 id="适配-Objective-C"><a href="#适配-Objective-C" class="headerlink" title="适配 Objective C"></a>适配 Objective C</h3><p>写这个部分的模板还是比较烦人的，因为 Objective C 并不支持 Swift 里面的所有类型。</p><p>首先是提供 Objective C 可以理解的 response body。就像之前所说的那样，我们只需要让一个 class 把每一个实现 <code>ResponseBodyType</code> 的类型包起来就行了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;٪<span class="keyword">for</span> responseBody <span class="keyword">in</span> types.all <span class="keyword">where</span> responseBody.implements.<span class="type">ResponseBodyType</span>%&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> </span>&#123;&#123;responseBody.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125;: <span class="type">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> body: &#123;&#123;responseBody.name&#125;&#125;</span><br><span class="line">    <span class="keyword">init</span>(body: &#123;&#123;responseBody.name&#125;&#125;) &#123; <span class="keyword">self</span>.body = body &#125;</span><br><span class="line">    &#123;٪<span class="keyword">for</span> variable <span class="keyword">in</span> responseBody.variables%&#125;</span><br><span class="line">    <span class="comment">// variables</span></span><br><span class="line">    &#123;٪endfor%&#125;</span><br><span class="line">&#123;٪endfor%&#125;</span><br></pre></td></tr></table></figure><p>Stencil 提供了一些内置的 filter，所以我们能够很简单地将一些嵌套类型的名称 <code>A.B.C</code> 转变成 <code>A_B_C</code>。Variable 部分需要比较注意的是，像 <code>Int?</code> 这种东西  Objective C 也是看不懂的，需要额外处理成 <code>NSNumber</code>，当 variable 是 <code>ResponseBodyType</code> 或 <code>[ResponseBodyType]</code> 或 <code>ResponseBodyType?</code> 之类的也需要额外处理，挺啰嗦的，这里就不一一写明了。Sourcery 中 <code>Variable</code> 有两个参数 <code>type</code> 和 <code>typeName</code>，说实话很诡异，必须得好好看文档才知道什么时候该用什么。</p><p>对 <code>ResponseBodyType?</code> 这种情况目前还没有很好的解决方法， <code>typeName.unwrappedTypeName</code> 返回的是 <code>String</code> 而不是 <code>TypeName</code>，正巧我把这些类型都嵌套在 <code>API</code> 里，可以判断其 <code>actualTypeName</code> 的前缀来捕获这种情况。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;٪<span class="keyword">if</span> variable.typeName.isOptional and variable.typeName.actualTypeName|hasPrefix:<span class="string">"API."</span> %&#125;</span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> &#123;&#123;variable.name&#125;&#125;: &#123;&#123;variable.typeName.actualTypeName.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> v = body.&#123;&#123;variable.name&#125;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#123;variable.type.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125;(body: v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;٪endif%&#125;</span><br></pre></td></tr></table></figure><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>提供 Objective C 版本的请求方法很简单，就是内部调用 Swift 版本的方法。这部分需要注意的只有一些 optional 的参数类型可能要用别的类型替换，就一笔带过了。</p><p>有了上一个小节的经验，我们可以发现这些模板的写法都大同小异。对方法签名的参数生成和请求参数的生成，无非都是遍历 <code>RequestBody</code> 的 <code>variables</code> 而已。唯一值得一提的是，我们可以用 <code>{٪if var.variables.count == 0%}</code> 来判断一个数组是否为空，还可以通过 <code>{٪if forloop.last%}</code> 来判断是否是当前循环的最后一次。很多用法其实都没有写在 Sourcery 的文档里面，不妨也去看看 Stencil 的文档。</p><h3 id="Coding-Keys"><a href="#Coding-Keys" class="headerlink" title="Coding Keys"></a>Coding Keys</h3><p>有时候我们希望不用去刻意地让属性的名称和 JSON 里的 key 完全对应上，因为有的 key 的命名真的是难以理解，这时我们也可以利用 Sourcery 帮助我们自动生成相关的代码。</p><p><a href="https://intii.com/2017/codable-enum-with-associated-values/%60">和我之前的文章一样</a>，我们用 <code>AutoCodable</code> 来指定这些需要生成代码的类型，但幸运的是，我们没有必要和 Enum with Associated Value 做斗争了。</p><p>仔细观察了一下，我大概有这么几个需求：</p><ol><li>类型为数组时，默认值为 <code>[]</code></li><li>可以指定默认值 <code>defaultValue = 0</code></li><li>可以指定 key <code>jsonKey = &quot;abc&quot;</code></li><li>某一些情况将 <code>Int</code> 转为 <code>Bool</code></li></ol><p>对于数组默认值，我们只需要把对应情况的 <code>decode</code> 改成 <code>decodeIfPresent ?? []</code> 就好了。</p><p>后三者则用到了 Sourcery 中的 annotation 功能，通过注释给 Sourcery 传递代码以外的信息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sourcery: jsonKey = "id"</span></span><br><span class="line"><span class="comment">// sourcery: defaultValue = 0</span></span><br><span class="line"><span class="keyword">let</span> productId: <span class="type">Int</span></span><br><span class="line"><span class="comment">// sourcery: boolFromInt</span></span><br><span class="line"><span class="keyword">let</span> worthBuying: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>模板中可以通过 <code>annotated</code> 这个 filter 来判断目标是否有相应的注释。也可以通过 <code>something.annotation.jsonKey</code> 这种方式来获取注释的值。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>元编程的一个好处就是没有复杂的设计，这使得扩展变得很容易。比如说，我们可以给 endpoint 增加一个获取 mock response 的功能。我们通过判断 endpoint 是否实现某一个 protocol 来决定是否插入代码。</p><p>对于这个扩展，endpoint 需要实现 <code>APIEndPointHasFakeResponse</code> 这个 protocol：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">APIEndPointHasFakeResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">handleRequestWithMockResponse</span><span class="params">(<span class="number">_</span> param: [String: Any]?, completionHandler: <span class="params">(Result&lt;Data&gt;)</span></span></span>-&gt;<span class="type">Void</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，我们既可以直接返回一段 JSON，也可以将请求转发给 mock server 来获取一段 mock response。当然我们也可以只对特定的请求做处理，并在这种情况下返回 <code>false</code>。</p><p>我们完全不用担心这些多余的扩展会污染我们的代码，毕竟这些代码只有在实现了协议的情况下才会插入到请求方法当中；我们也可以在 extension 中实现这个协议，以保持 endpoint 定义的纯洁性，当我们不需要 mock response 了，只需要随手删掉相关代码就可以了。</p><p>我们也可以只移除 protocol 而保留方法的实现，以方便下一次使用。</p><p>我们可以把这一部分写成一个 macro：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;٪macro extensionFakeResponse type requestBody%&#125;</span><br><span class="line">&#123;٪<span class="keyword">if</span> type.implements.<span class="type">APIEndPointHasFakeResponse</span>%&#125;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">        <span class="keyword">if</span> &#123;&#123;type.name&#125;&#125;.handleRequestWithMockResponse(&#123;٪call paramOrNil requestBody-%&#125;, completionHandler: &#123; </span><br><span class="line">            <span class="keyword">switch</span> $<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .success(json):</span><br><span class="line">                <span class="keyword">let</span> result = <span class="keyword">try</span>! <span class="type">JSONDecoder</span>().decode(<span class="type">APIResponse</span>&lt;&#123;&#123;type.name&#125;&#125;.<span class="type">ResponseBody</span>&gt;.<span class="keyword">self</span>, from: json!)</span><br><span class="line">                completion(.success(result.body))</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .failure(error): completion(.failure(error))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">#endif</span><br><span class="line">&#123;٪endif%&#125;</span><br><span class="line">&#123;٪endmacro%&#125;</span><br></pre></td></tr></table></figure><p>这样就能尽可能使请求方法模板看起来更干净一些。尽管生成的代码是挺丑的，不过谁要去管它们呢。</p><p>很遗憾 Sourcery 好像还并不支持 <code>indent</code> 这个 filter，所以当缩进有点深的时候，模板会变得很难看（尽管官方好像说是支持的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不太喜欢现在公司项目中 API Client 的实现方式，虽然并没有什么问题，但我还是忍不住要重构一下。原本的实现是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeModel&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)doSomething:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)aParam completion:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; isSuccess, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *errorMessage, SomeModel * someModel))completion &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [APIClient.sharedClient &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        POST:someEndpoint&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parameters: @&amp;#123; &lt;span class=&quot;string&quot;&gt;@&quot;p&quot;&lt;/span&gt;: aParam &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        success:^(&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; * _Nonnull task, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;  _Nullable responseObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            PPApiResponseObject *responseItem = [PPApiResponseObject createFrom:responseObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (responseItem.isSuccess) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        failure:^(&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; * _Nullable task, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nonnull error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有几个地方是我不喜欢的：1. 用 Objective C 写的；2. API 不太现代；3. endpoint 分散在了不同的 model 定义里面；4. 重复的东西太多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Objective C" scheme="http://intii.com/tags/Objective-C/"/>
    
      <category term="Sourcery" scheme="http://intii.com/tags/Sourcery/"/>
    
      <category term="Meta Programming" scheme="http://intii.com/tags/Meta-Programming/"/>
    
      <category term="元编程" scheme="http://intii.com/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重构" scheme="http://intii.com/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>接手别人的项目</title>
    <link href="http://intii.com/2018/refactoring-others-project-001/"/>
    <id>http://intii.com/2018/refactoring-others-project-001/</id>
    <published>2018-06-09T03:21:00.000Z</published>
    <updated>2018-11-25T14:20:17.742Z</updated>
    
    <content type="html"><![CDATA[<p>在城大的工作终于是结束了。用了「终于」两个字，是因为我再也不能承受这份工作了，虽然他们允许我远程工作，在工作中我的时间安排相当自由，做的内容也是比较自由，但是正因为太自由了，我发现我在里面投入了过多的时间与精力——描述太过「简单」的需求让我很难界定范围。而教授又希望他的 app 能够「充满不同游戏」，这个状态一直都在持续。</p><p>于是我找了一份朝九晚六周末休息、离家还算近的工作。一切都还挺好的，只是接手代码这件事让我有些难受。</p><a id="more"></a><p>先谈谈这个项目有什么问题。</p><h2 id="Massive-View-Controller"><a href="#Massive-View-Controller" class="headerlink" title="Massive View Controller"></a>Massive View Controller</h2><p>每个页面基本上就是靠着一个 view controller 撑着，业务逻辑和 UI 逻辑混在一起，我看到过一个 2000+ 行的。</p><h2 id="不够-MVC"><a href="#不够-MVC" class="headerlink" title="不够 MVC"></a>不够 MVC</h2><p>这个项目里 view 绝对是「一等公民」。view 不仅能够控制页面跳转，有时还承担了一些业务逻辑。</p><p>将这些放到 view 去做就算了，还偷懒不给足够的上下文。之前就遇到了一个遗留 bug：一个弹窗弹到了错误的地方。原因是弹窗的逻辑写到了 view 里，而 view 竟然将弹窗作为 subview 加到了 <code>[[[[UIApplication sharedApplication] delegate] window] rootViewController].view</code> 上，显然在某一版之前这个逻辑（恰好）是正确的，某一版之后他们决定不把这个页面 push 到作为 <code>rootViewcontroller</code> 的 navigation controller 里面了，就出现了这个问题。<br><img src="/media/refactoring-others-project-001/incorrect-position-of-popup.png" alt="incorrect-position-of-popup"></p><p>我猜这个 bug 已经存在很久了……这种写法也为接手的人带来了极大的困难，现在我需要每个 view 都点开看看才知道发生了什么。</p><h2 id="View-的依赖太随便"><a href="#View-的依赖太随便" class="headerlink" title="View 的依赖太随便"></a>View 的依赖太随便</h2><p><img src="/media/refactoring-others-project-001/better-way-to-pass-dependency-1.png" alt="better-way-to-pass-dependency"></p><p>有些时候上下文也是给得太足。比如说有这么一个 cell，本来传进去三样东西就足够了，在这个项目中却为了写时方便传入了硕大无比的 object，再在 cell 的内部决定使用什么内容。<br><img src="/media/refactoring-others-project-001/wrong-way-to-pass-dependency-1.png" alt="wrong-way-to-pass-dependency"></p><p>对于没有接触过这个项目的人来说很难去理清究竟用了什么没用什么，我甚至会担心把这个 mutable 的东西传来传去，会不会发生了什么意料之外的写操作。另外就是要单独测试这个 cell 的话，就需要先去创建这样的一个巨大 object 了，很麻烦。</p><h2 id="充满了-Magic-Value"><a href="#充满了-Magic-Value" class="headerlink" title="充满了 Magic Value"></a>充满了 Magic Value</h2><p>这次是中途接手了别人的 0.1.0 级别更新，我没有时间先大概了解这个项目和这个版本的需求，就要开始写代码了。到了最后一天的下午，设计师突然跟我说要把某个间距从 15 改成 20。这当然应该是很简单的事情，可却把我给难住了，因为这个间距所在的 <code>UICollectionViewCell</code> 的高度计算方法里是这种样子的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> height = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">height += <span class="number">15</span> + somethingsHeight + <span class="number">20</span> + <span class="number">5</span> + <span class="number">10</span> + <span class="number">15</span>;</span><br><span class="line">...</span><br><span class="line">height += anotherHeight + <span class="number">20</span> + <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (showThis) &#123; height += <span class="number">5</span> + thisHeight + <span class="number">20</span> + <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br></pre></td></tr></table></figure><p>更可怕的是，我尝试去改了一下数字，界面却没有发生变化。对不起，我只能想办法让它变宽一些，具体宽多少，我暂时还没有办法控制，等下一版吧。</p><p>在 iPhone X 的适配上也是使用了判断机型提供相应 magic value 的方式，我已经预感到下一次适配时的痛苦了。</p><h2 id="太喜欢宏定义"><a href="#太喜欢宏定义" class="headerlink" title="太喜欢宏定义"></a>太喜欢宏定义</h2><p>并不是说宏定义不好，我也喜欢用宏定义来实现 Objc 下的 let 和 var，但是有些常量实际上用其他方式来表示会更好一些。比如说颜色，这个项目有一个主题色被定义成了常量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define GLOBAL_TINTCOLOR UIColorFromRGB(0x12abcd)</span></span><br></pre></td></tr></table></figure><p>我总是不记得这个宏叫什么，因为还存在很多其它名称各异的颜色常量，叫做 <code>XXXX_COLOR</code>、<code>XXXX_COLOR_XXX</code> 或者 <code>ColorForXXXXX</code>，甚至还有 <code>COLOR_0xAAAAAA</code> 这样的东西。要说它们命名能规范一些、定义能集中一些，问题倒是不大，但它们基本上是东一个西一个，名称格式也各式各样，除非记得名字，想找到它们还是很麻烦的，自动补全都帮不了你。</p><p>其实写成 <code>UIColor</code> 的 category 不就完了嘛。</p><h2 id="太多-Warning"><a href="#太多-Warning" class="headerlink" title="太多 Warning"></a>太多 Warning</h2><p>我第一次 build 这个项目的时候真是惊呆了，300 多个 warning，其中可能有一半是因为用了 iOS 9 或之前开始 deprecate 的 API。我掐指一算，9、10、11、12，这些难道不应该两年前就清掉吗，反倒还在继续用。我也没法现在就动手把它们全部改掉，只好先写个 wrapper 把它们都包住，关掉 deprecated functions 的 warning，日后再统一处理。</p><p>然后还有很多「Prototype xxx cells must have reuse identifiers」，我猜是上面的一百来个 warning 蒙蔽了他的双眼。还有一些「隐式类型转换可能会影响精度」啊、类型不匹配啊、或者输入了奇怪的符号但会被当作空格……能改的我都改了，还有一些莫名其妙的、不敢改的、来自第三方库的，现在还有 46 个 warning。</p><p>看到这么多 warning，你们就不心疼？心疼是小事，重要的 warning 被淹没了可是大事。</p><h2 id="太喜欢第三方库，尤其是-UI-方面"><a href="#太喜欢第三方库，尤其是-UI-方面" class="headerlink" title="太喜欢第三方库，尤其是 UI 方面"></a>太喜欢第三方库，尤其是 UI 方面</h2><p>用是可以的，但能不能不要挑那种没有 star、上传之后就没下文的库呢。这种库往往都没法开箱即用，拖下来也是一顿改。这读别人代码然后强行改成符合需求的时间，我觉得自己写早写完了，最终效果和过程体验都得好不少。</p><p>而对于一个接手项目的人来说，读这种充满补丁的代码更是噩梦。</p><h2 id="干脆就复制粘贴吧"><a href="#干脆就复制粘贴吧" class="headerlink" title="干脆就复制粘贴吧"></a>干脆就复制粘贴吧</h2><p>项目里充满了内部复制粘贴的代码。在很多情况下，复制粘贴其实还不错。但像以下这种类型的复制粘贴真的是非常糟糕了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SomeViewController *vc = [SomeViewController new];</span><br><span class="line">[vc initializeWithSomeProperties];</span><br><span class="line"><span class="built_in">UINavigationController</span> *nav = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:vc];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:nav];</span><br></pre></td></tr></table></figure><p><strong>天知道这要包在一个 <code>UINavigationController</code> 里面噢。</strong></p><p>这种情况，把 <code>SomeViewController</code> 直接做成一个 <code>UINavigationController</code> 或者是用一个 navigation coordinator 来控制跳转，怕不是要强个一百倍。</p><p>这种代码的复制粘贴还有不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在城大的工作终于是结束了。用了「终于」两个字，是因为我再也不能承受这份工作了，虽然他们允许我远程工作，在工作中我的时间安排相当自由，做的内容也是比较自由，但是正因为太自由了，我发现我在里面投入了过多的时间与精力——描述太过「简单」的需求让我很难界定范围。而教授又希望他的 app 能够「充满不同游戏」，这个状态一直都在持续。&lt;/p&gt;
&lt;p&gt;于是我找了一份朝九晚六周末休息、离家还算近的工作。一切都还挺好的，只是接手代码这件事让我有些难受。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://intii.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>如何引用一个值类型属性</title>
    <link href="http://intii.com/2018/how-to-reference-to-a-value-type-property/"/>
    <id>http://intii.com/2018/how-to-reference-to-a-value-type-property/</id>
    <published>2018-04-02T06:06:55.000Z</published>
    <updated>2018-04-02T06:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在更新 Best Before 的过程中，我决定重写 <code>ForwardStrategy</code> 的部分。过去 <code>ForwardStrategy</code> 中不同的转发目标所储存的信息其实是一样的，只是不同的转发目标会隐藏其不包含的属性。因此其对应的表单也是这样设计的，表单中其实包含了所有属性对应的 cell，但是在选中某些目标时，其中一些 cell 被隐藏起来了。</p><p>举个例子吧：比如说我们有 Things 和 Mail 两种转发目标，当我们选中 Things 时，因为它并没有收件人，所以其对应的 cell 被隐藏起来了。当我们切换到 Mail，收件人就得以重见天日，但截止日期却被隐藏起来了。这个方案当然是 work 的，但是却有一个明显的缺点，一旦我们需要添加新的转发目标，或更新旧有的转发目标时出现了新的属性时，我们就需要修改模型，并在表单中增加新的 cell 了。</p><p>因此在这次更新中，我决定将转发目标的属性以 JSON 为格式储存，这也避免了不同转发目标混用属性的尴尬。表单方面也需要作出修改。窒息观察可以发现，这些属性有几个固定的类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ForwardFormElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> highlightTextView(title: <span class="type">String</span>, placeholder: <span class="type">String</span>?, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> textView(title: <span class="type">String</span>, placeholder: <span class="type">String</span>?, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> textField(title: <span class="type">String</span>, placeholder: <span class="type">String</span>?, keyboardType: <span class="type">UIKeyboardType</span>, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> picker(title: <span class="type">String</span>, options: [<span class="type">String</span>], bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">Int</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> toggle(title: <span class="type">String</span>, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">Bool</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要提供每一种转发目标的 <code>[ForwardFormElement]</code>，就能依次利用 Form Builder 生成相应的表单了。同时也为了契合我在用的 Form Builder 的特点，我希望在生成每一个 <code>Row</code> 时能够通过它的 <code>onChange</code> 方法将变动绑定到转发目标的相关属性上。这才有了本篇文章的主题。</p><a id="more"></a><p>先梳理一下，我希望的结果是：</p><ol><li>转发目标提供 <code>[ForwardFormElement]</code> 给 Form Builder</li><li>ForwardFormElement 中包含了一个对转发目标属性的弱引用</li><li>Form Builder 生成 <code>Row</code> 时通过 <code>onChange</code> 方法绑定属性<br> <code>row.onChange { bind.val = $0 }</code></li><li><code>bind.val</code> 改变时同时改变转发目标的相关属性（很可能是值类型）</li></ol><p>那么接下来就是怎么实现 <code>bind: PropertyRefTo&lt;T&gt;</code> 的问题了。</p><p>很简单，Swift 4 给我们带来了 KeyPath subscription，只要我们持有转发目标的弱引用，然后再存对应的 KeyPath 就好了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRefTo</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val: <span class="type">V</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyRef</span>&lt;<span class="title">O</span>: <span class="title">AnyObject</span>, <span class="title">V</span>&gt;: <span class="title">PropertyRefTo</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> object: <span class="type">O</span>?</span><br><span class="line">    <span class="keyword">let</span> keyPath: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">O</span>, <span class="type">V</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">O</span>, <span class="number">_</span> keyPath: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">O</span>, <span class="type">V</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.object = object</span><br><span class="line">        <span class="keyword">self</span>.keyPath = keyPath</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> val: <span class="type">V</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object?[keyPath: keyPath]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> v = newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            object?[keyPath: keyPath] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能用吗？能用。但是我还有一个额外的需求，有一些对应 <code>case picker(title: String, options: [String], bind: PropertyRefTo&lt;Int&gt;)</code> 的属性是 Enum，但 Swift 并没有 Generic Case 这样的东西，所以我们要让 <code>PropertyRef</code> 能够按照我们的要求将其 <code>val</code> 转换成我们需要的类型。显而易见，不提供 <code>object</code> 和 <code>keyPath</code>，而是提供 <code>val</code> 的 getter 和 setter 不就好了吗。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">O</span>, getter: @escaping (<span class="type">O</span>)-&gt;<span class="type">V</span>?, setter: @escaping (<span class="type">O</span>, <span class="type">V</span>)-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.getter = &#123;</span><br><span class="line">        [<span class="keyword">weak</span> object] <span class="keyword">in</span> <span class="keyword">guard</span> <span class="keyword">let</span> object = object <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> getter(object)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.setter = &#123;</span><br><span class="line">        [<span class="keyword">weak</span> object] newValue <span class="keyword">in</span> <span class="keyword">guard</span> <span class="keyword">let</span> object = object <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        setter(object, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 block 里通过 capture list 弱引用 <code>object</code>，因为这么写了，所以我们要求 <code>O: AnyObject</code>。最后 Key Path 这种这么方便的东西，我们也可以提供一个 convenience initializer。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">O</span>, <span class="number">_</span> keyPath: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">O</span>, <span class="type">V</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(object, getter: &#123; $<span class="number">0</span>[keyPath: keyPath] &#125;, setter: &#123; $<span class="number">0</span>[keyPath: keyPath] = $<span class="number">1</span> &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们就能获得一个 <code>AnyObject</code> 的非引用类型的属性的引用啦。</p><p>随后代码就可以写成</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.highlightTextView(</span><br><span class="line">    title: <span class="type">Localized</span>.<span class="type">This</span>.<span class="type">Form</span>.<span class="type">Things</span>.notes, </span><br><span class="line">    placeholder: <span class="type">Localized</span>.<span class="type">This</span>.<span class="type">Form</span>.<span class="type">Things</span>.notesPlaceholder, </span><br><span class="line">    bind: <span class="type">PropertyRef</span>(<span class="keyword">self</span>, \.notes)),</span><br><span class="line">.picker(</span><br><span class="line">    title: <span class="type">Localized</span>.<span class="type">This</span>.<span class="type">Form</span>.<span class="type">Things</span>.deadline, </span><br><span class="line">    options: <span class="type">DeadlineType</span>.allTitles,</span><br><span class="line">    bind: <span class="type">PropertyRef</span>(<span class="keyword">self</span>, getter: &#123; $<span class="number">0</span>.deadlineType.identifier &#125;</span><br><span class="line">                            setter: &#123; $<span class="number">0</span>.deadlineType = <span class="type">DeadlineType</span>(identifier: $<span class="number">1</span>) &#125;)),</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在更新 Best Before 的过程中，我决定重写 &lt;code&gt;ForwardStrategy&lt;/code&gt; 的部分。过去 &lt;code&gt;ForwardStrategy&lt;/code&gt; 中不同的转发目标所储存的信息其实是一样的，只是不同的转发目标会隐藏其不包含的属性。因此其对应的表单也是这样设计的，表单中其实包含了所有属性对应的 cell，但是在选中某些目标时，其中一些 cell 被隐藏起来了。&lt;/p&gt;
&lt;p&gt;举个例子吧：比如说我们有 Things 和 Mail 两种转发目标，当我们选中 Things 时，因为它并没有收件人，所以其对应的 cell 被隐藏起来了。当我们切换到 Mail，收件人就得以重见天日，但截止日期却被隐藏起来了。这个方案当然是 work 的，但是却有一个明显的缺点，一旦我们需要添加新的转发目标，或更新旧有的转发目标时出现了新的属性时，我们就需要修改模型，并在表单中增加新的 cell 了。&lt;/p&gt;
&lt;p&gt;因此在这次更新中，我决定将转发目标的属性以 JSON 为格式储存，这也避免了不同转发目标混用属性的尴尬。表单方面也需要作出修改。窒息观察可以发现，这些属性有几个固定的类型：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ForwardFormElement&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; highlightTextView(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, placeholder: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; textView(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, placeholder: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; textField(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, placeholder: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, keyboardType: &lt;span class=&quot;type&quot;&gt;UIKeyboardType&lt;/span&gt;, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; picker(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, options: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;], bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; toggle(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们只需要提供每一种转发目标的 &lt;code&gt;[ForwardFormElement]&lt;/code&gt;，就能依次利用 Form Builder 生成相应的表单了。同时也为了契合我在用的 Form Builder 的特点，我希望在生成每一个 &lt;code&gt;Row&lt;/code&gt; 时能够通过它的 &lt;code&gt;onChange&lt;/code&gt; 方法将变动绑定到转发目标的相关属性上。这才有了本篇文章的主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="KeyPath" scheme="http://intii.com/tags/KeyPath/"/>
    
      <category term="ReferenceWritableKeyPath" scheme="http://intii.com/tags/ReferenceWritableKeyPath/"/>
    
      <category term="Reference" scheme="http://intii.com/tags/Reference/"/>
    
      <category term="Value Type" scheme="http://intii.com/tags/Value-Type/"/>
    
  </entry>
  
  <entry>
    <title>用 Blend Mode 来让 Navigation Bar 骚气起来</title>
    <link href="http://intii.com/2018/decorate-uinavigationbar-with-blend-mode/"/>
    <id>http://intii.com/2018/decorate-uinavigationbar-with-blend-mode/</id>
    <published>2018-03-13T06:21:00.000Z</published>
    <updated>2018-11-25T14:17:27.810Z</updated>
    
    <content type="html"><![CDATA[<p>最近又在更新 Best Before.app，算是把同步写好了，但是还是打算顺便更新一下 UI。之前加入了自定义分类的功能，还允许用户给分类设置一个颜色，但是这个颜色却没有什么实际的作用，在这次更新中我打算在 Navigation Bar 上面显示出这个颜色。</p><p><img src="/media/decorate-uinavigationbar-with-blend-mode/old.png" width="375px" alt="old"/></p><p>应该怎么显示呢，一开始我的想法是让分类名称的第一个字符设置为这个颜色。尽管 <code>UINavigationBar</code> 并没有给我们提供一个 API 去做这个事情，我们还是能够很暴力地从其众多的 <code>subviews</code> 的 <code>subviews</code> 当中，找到这些 <code>UILabel</code>。如果 iOS 还没到 11，这就足够了，但是 iOS 11 中却引入了 Large Title，而即便我们修改了 Large Title 的 <code>attributedString</code>，它也会在我们拖动底下的 scroll view 时打回原形。</p><p>很讨厌。</p><a id="more"></a><p>这时我想起了 Sketch 中 Blend Mode，在 Sketch 用 Blend Mode Lighten 能够将颜色附着在图标上，虽然没法简单地定位到刚好只覆盖到第一个字符，但好像也挺拉风的，于是我在 Sketch 里面做了一些修改。</p><p><img src="/media/decorate-uinavigationbar-with-blend-mode/new.png" width="375px" alt="new"/></p><p>那 iOS 上是否有这样的功能呢。</p><p>居然有，我们只需要在 <code>UINavigationBar</code> 上添加一个 <code>CALayer</code>，并将其的 <code>compositingFilter</code> 赋值为 <code>lightenBlendMode</code> 就可以了。同时还要 observe Navigation Bar 的 <code>frame</code> 以随着它的高度变动修改这个 layer 的 <code>path</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNavigationBarBlending</span><span class="params">()</span></span> &#123;</span><br><span class="line">    blendLayer = &#123;</span><br><span class="line">        <span class="keyword">let</span> it = <span class="type">CAShapeLayer</span>()</span><br><span class="line">        it.compositingFilter = <span class="string">"lightenBlendMode"</span></span><br><span class="line">        navigationBar.layer.addSublayer(it)</span><br><span class="line">        <span class="keyword">let</span> observation = navigationBar.observe(\.frame) &#123; bar, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            it.path = <span class="type">UIBezierPath</span>(rect: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, </span><br><span class="line">                                                width: <span class="number">50</span>, </span><br><span class="line">                                                height: bar.frame.height)).cgPath</span><br><span class="line">        &#125;</span><br><span class="line">        disposables.append(observation)</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要在显示分类列表时，修改 <code>blendLayer</code> 的 <code>fillColor</code> 就行了。值得一提的是 <code>UINavigationBar.frame</code> 恰好只包含到了 Large Title View，并不包括搜索框。</p><p>当然如果再花些功夫，也还是能让它只覆盖到第一个字符的，但是也没必要了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又在更新 Best Before.app，算是把同步写好了，但是还是打算顺便更新一下 UI。之前加入了自定义分类的功能，还允许用户给分类设置一个颜色，但是这个颜色却没有什么实际的作用，在这次更新中我打算在 Navigation Bar 上面显示出这个颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/decorate-uinavigationbar-with-blend-mode/old.png&quot; width=&quot;375px&quot; alt=&quot;old&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应该怎么显示呢，一开始我的想法是让分类名称的第一个字符设置为这个颜色。尽管 &lt;code&gt;UINavigationBar&lt;/code&gt; 并没有给我们提供一个 API 去做这个事情，我们还是能够很暴力地从其众多的 &lt;code&gt;subviews&lt;/code&gt; 的 &lt;code&gt;subviews&lt;/code&gt; 当中，找到这些 &lt;code&gt;UILabel&lt;/code&gt;。如果 iOS 还没到 11，这就足够了，但是 iOS 11 中却引入了 Large Title，而即便我们修改了 Large Title 的 &lt;code&gt;attributedString&lt;/code&gt;，它也会在我们拖动底下的 scroll view 时打回原形。&lt;/p&gt;
&lt;p&gt;很讨厌。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="UINavigationBar" scheme="http://intii.com/tags/UINavigationBar/"/>
    
      <category term="iOS 11" scheme="http://intii.com/tags/iOS-11/"/>
    
      <category term="Large Title" scheme="http://intii.com/tags/Large-Title/"/>
    
      <category term="Customization" scheme="http://intii.com/tags/Customization/"/>
    
      <category term="Blending Mode" scheme="http://intii.com/tags/Blending-Mode/"/>
    
  </entry>
  
  <entry>
    <title>新头像，超清猎人</title>
    <link href="http://intii.com/2018/avatar-uhd-hunter/"/>
    <id>http://intii.com/2018/avatar-uhd-hunter/</id>
    <published>2018-01-21T10:21:31.000Z</published>
    <updated>2018-03-13T04:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>热烈庆祝 MHW 面世。<br><a id="more"></a><br><img src="/media/avatar-uhd-hunter.jpg" alt="avatar-charge-blade-maste"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;热烈庆祝 MHW 面世。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codable Enum with Associated Values</title>
    <link href="http://intii.com/2017/codable-enum-with-associated-values/"/>
    <id>http://intii.com/2017/codable-enum-with-associated-values/</id>
    <published>2017-10-19T06:21:00.000Z</published>
    <updated>2018-11-25T14:17:27.803Z</updated>
    
    <content type="html"><![CDATA[<p>我们决定在项目中使用 JSON 来储存每一个章节的信息，于是就出现了一个需求，JSON 里面的数组里可能会存在多种 Object，要举个栗子的话，就是一台战舰上可能会同时搭载了一些 Mobile Suits 和 Mobile Armor，而且它们还是放在一块儿的，却又有着不同类型的属性。<br><img src="/media/codable_enum_with_associated_values/msandma.png" width="340px"></p><p>既然我们在用 Swift，就很自然的想用 Enum 来表示它们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Unit</span>: <span class="title">Codable</span> </span>&#123;            <span class="comment">// &#123;</span></span><br><span class="line">    <span class="keyword">case</span> mobileArmor(           <span class="comment">//   "type": "mobile-armor",</span></span><br><span class="line">        numberOfPilots: <span class="type">Int</span>     <span class="comment">//   "number-of-pilots": 2</span></span><br><span class="line">    )                           <span class="comment">// &#125;,</span></span><br><span class="line">                                <span class="comment">// &#123;</span></span><br><span class="line">    <span class="keyword">case</span> mobileSuit(            <span class="comment">//   "type": "mobile-suit"</span></span><br><span class="line">        numberOfLegs: <span class="type">Int</span>,      <span class="comment">//   "number-of-leg": 2,</span></span><br><span class="line">        isGundam: <span class="type">Bool</span>          <span class="comment">//   "is-gundam": true</span></span><br><span class="line">    )                           <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Mobile Armor，它可能需要好几个驾驶员负责四肢和头部，但对于 Mobile Suit，上头则更在乎它们有多少只脚，以及<ruby>是不是高达<rt>有没有光环</rt></ruby>。当我们直接加上 <code>Codable</code>，Compiler 就报错了，显然我们需要手动做一些什么奇怪的事情才行。</p><a id="more"></a><p>易知，Compiler 没有恰当的手段给我们自动生成 <code>CodingKey</code>，对于普通的 Enum，我们可以指定 Enum 的 raw value 的类型来解决问题，但带有 associated values 的 Enum 则不允许我们这么做，所以我们得手动添加 <code>CodingKey</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> type</span><br><span class="line">    <span class="keyword">case</span> numberOfLegs = <span class="string">"number-of-legs"</span>, isGundam = <span class="string">"is-gundam"</span></span><br><span class="line">    <span class="keyword">case</span> numberOfPilots = <span class="string">"number-of-pilots"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们还需要实现 <code>init(from decoder: Decoder)</code>：  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .type)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mobile-suit"</span>:</span><br><span class="line">        <span class="keyword">let</span> numberOfLegs = <span class="keyword">try</span> values.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .numberOfLegs)</span><br><span class="line">        <span class="keyword">let</span> isGundam = <span class="keyword">try</span> values.decode(<span class="type">Bool</span>.<span class="keyword">self</span>, forKey: .isGundam)</span><br><span class="line">        <span class="keyword">self</span> = .mobileSuit(numberOfLegs: numberOfLegs, isGundam: isGundam)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mobile-armor"</span>:</span><br><span class="line">        <span class="keyword">let</span> numberOfPilots = <span class="keyword">try</span> values.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .numberOfPilots)</span><br><span class="line">        <span class="keyword">self</span> = .mobileArmor(numberOfPilots: numberOfPilots)</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="type">UnitError</span>.decoding(<span class="string">"error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样把不同 case 的 coding keys 都放在一起是比较危险的，即便是新人类或者调整者，也不能保证不会手残，在生成 MS 资料的时候去读取了一个不存在的、属于 MA 的 key。所以要是想再 type safe 一些的话，可以把不同 case 的 coding keys 放在不同的 Enum 里面，防止敲错 key：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">MobileArmorCodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> numberOfPilots = <span class="string">"number-of-pilots"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mobile-armor"</span>:</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">MobileArmorCodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> numberOfPilots = <span class="keyword">try</span> values.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .numberOfPilots)</span><br><span class="line">        <span class="keyword">self</span> = .mobileArmor(numberOfPilots: numberOfPilots)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Encode 部分也是同理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .mobileSuit(numberOfLegs, isGundam):</span><br><span class="line">        <span class="keyword">try</span> container.encode(<span class="string">"mobile-suit"</span>, forKey: .type)</span><br><span class="line">        <span class="keyword">var</span> values = encoder.container(keyedBy: <span class="type">MobileSuitCodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> values.encode(isGundam, forKey: .isGundam)</span><br><span class="line">        <span class="keyword">try</span> values.encode(numberOfLegs, forKey: .numberOfLegs)</span><br><span class="line">    <span class="keyword">case</span> .mobileArmor(<span class="keyword">let</span> numberOfPilots):...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json =＂＂＂</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"mobile-suit"</span>,</span><br><span class="line">        <span class="string">"is-gundam"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"number-of-legs"</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"mobile-armor"</span>,</span><br><span class="line">        <span class="string">"number-of-pilots"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">＂＂＂</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">try</span>! decoder.decode([<span class="type">Unit</span>].<span class="keyword">self</span>, from: json.data(using: .utf8)!)</span><br><span class="line"><span class="comment">// [Unit.mobileSuit(numberOfLegs: 4, isGundam: true), Unit.mobileArmor(2)]</span></span><br><span class="line"><span class="keyword">let</span> encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span>! encoder.encode(result)</span><br><span class="line"><span class="comment">// [&#123;"type":"mobile-suit","number-of-legs":4,"is-gundam":true&#125;,&#123;"type":"mobile-armor","number-of-pilots":2&#125;]</span></span><br></pre></td></tr></table></figure><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>后来我在别的项目中又遇到了这个需求，并决定用 Sourcery 给我自动生成这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% <span class="keyword">for</span> <span class="class"><span class="keyword">enum</span> <span class="title">in</span> <span class="title">types</span>.<span class="title">implementing</span>.<span class="title">AutoCodableEnumWithAssociatedValue</span>|<span class="title">enum</span> %&#125;</span></span><br><span class="line"><span class="class"></span>&#123;% <span class="keyword">if</span> <span class="class"><span class="keyword">enum</span>.<span class="title">hasAssociatedValues</span> %&#125;</span></span><br><span class="line"><span class="class">// <span class="title">MARK</span>: </span>&#123;&#123; <span class="class"><span class="keyword">enum</span>.<span class="title">name</span> &#125;&#125; <span class="title">Codable</span></span></span><br><span class="line"><span class="class"><span class="title">extension</span> </span>&#123;&#123; <span class="class"><span class="keyword">enum</span>.<span class="title">name</span> &#125;&#125;: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;% <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="class"><span class="keyword">enum</span>.<span class="title">cases</span> %&#125;</span></span><br><span class="line"><span class="class">    </span>&#123;% <span class="keyword">if</span> <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> </span>&#123;&#123;<span class="keyword">case</span>.name | upperFirstLetter&#125;&#125;<span class="type">CodingKeys</span>: <span class="type">String</span>, <span class="type">CodingKey</span> &#123;</span><br><span class="line">        &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">        <span class="keyword">case</span> &#123;&#123; value.localName &#125;&#125; = <span class="string">"&#123;&#123; value.localName | camelToSnakeCase &#125;&#125;"</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> type = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .type)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        &#123;% <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="class"><span class="keyword">enum</span>.<span class="title">cases</span> %&#125;</span></span><br><span class="line"><span class="class">        </span>&#123;% <span class="keyword">if</span> not <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>: <span class="keyword">self</span> = .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;    </span><br><span class="line">        &#123;% endif %&#125;            </span><br><span class="line">        &#123;% <span class="keyword">if</span> <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>:</span><br><span class="line">            <span class="keyword">let</span> values = <span class="keyword">try</span> decoder.container(keyedBy: &#123;&#123;<span class="keyword">case</span>.name | upperFirstLetter&#125;&#125;<span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">            &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">            <span class="keyword">let</span> &#123;&#123;value.localName&#125;&#125; = <span class="keyword">try</span> values.decode(&#123;&#123;value.typeName&#125;&#125;.<span class="keyword">self</span>, forKey: .&#123;&#123;value.localName&#125;&#125;)</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">            <span class="keyword">self</span> = .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;(</span><br><span class="line">                &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">                &#123;&#123;value.localName&#125;&#125;: &#123;&#123;value.localName&#125;&#125;&#123;% <span class="keyword">if</span> not forloop.last %&#125;,&#123;% endif %&#125;</span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            )</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="type">EncodingError</span>.invalidValue(type, .<span class="keyword">init</span>(codingPath: [<span class="type">CodingKeys</span>.type], debugDescription: <span class="string">"<span class="subst">\(type)</span> is not found in cases of &#123;&#123;enum.name&#125;&#125;"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        &#123;% <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="class"><span class="keyword">enum</span>.<span class="title">cases</span> %&#125;</span></span><br><span class="line"><span class="class">        </span>&#123;% <span class="keyword">if</span> not <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;: <span class="keyword">try</span> container.encode(<span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>, forKey: .type)   </span><br><span class="line">        &#123;% endif %&#125;            </span><br><span class="line">        &#123;% <span class="keyword">if</span> <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;(&#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;&#123;&#123;value.localName&#125;&#125;&#123;% <span class="keyword">if</span> not forloop.last %&#125;, &#123;% endif %&#125;&#123;% endfor %&#125;):</span><br><span class="line">            <span class="keyword">try</span> container.encode(<span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>, forKey: .type)</span><br><span class="line">            <span class="keyword">var</span> values = encoder.container(keyedBy: &#123;&#123;<span class="keyword">case</span>.name | upperFirstLetter&#125;&#125;<span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">            &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">            <span class="keyword">try</span> values.encode(&#123;&#123;value.localName&#125;&#125;, forKey: .&#123;&#123;value.localName&#125;&#125;)</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们决定在项目中使用 JSON 来储存每一个章节的信息，于是就出现了一个需求，JSON 里面的数组里可能会存在多种 Object，要举个栗子的话，就是一台战舰上可能会同时搭载了一些 Mobile Suits 和 Mobile Armor，而且它们还是放在一块儿的，却又有着不同类型的属性。&lt;br&gt;&lt;img src=&quot;/media/codable_enum_with_associated_values/msandma.png&quot; width=&quot;340px&quot;&gt;&lt;/p&gt;
&lt;p&gt;既然我们在用 Swift，就很自然的想用 Enum 来表示它们：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Unit&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Codable&lt;/span&gt; &lt;/span&gt;&amp;#123;            &lt;span class=&quot;comment&quot;&gt;// &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mobileArmor(           &lt;span class=&quot;comment&quot;&gt;//   &quot;type&quot;: &quot;mobile-armor&quot;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numberOfPilots: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;//   &quot;number-of-pilots&quot;: 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )                           &lt;span class=&quot;comment&quot;&gt;// &amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;comment&quot;&gt;// &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mobileSuit(            &lt;span class=&quot;comment&quot;&gt;//   &quot;type&quot;: &quot;mobile-suit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numberOfLegs: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;,      &lt;span class=&quot;comment&quot;&gt;//   &quot;number-of-leg&quot;: 2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isGundam: &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;          &lt;span class=&quot;comment&quot;&gt;//   &quot;is-gundam&quot;: true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )                           &lt;span class=&quot;comment&quot;&gt;// &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于 Mobile Armor，它可能需要好几个驾驶员负责四肢和头部，但对于 Mobile Suit，上头则更在乎它们有多少只脚，以及&lt;ruby&gt;是不是高达&lt;rt&gt;有没有光环&lt;/rt&gt;&lt;/ruby&gt;。当我们直接加上 &lt;code&gt;Codable&lt;/code&gt;，Compiler 就报错了，显然我们需要手动做一些什么奇怪的事情才行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>像写 Swift 那样写 Objective-C</title>
    <link href="http://intii.com/2017/write-objc-like-writing-swift/"/>
    <id>http://intii.com/2017/write-objc-like-writing-swift/</id>
    <published>2017-08-11T14:23:10.000Z</published>
    <updated>2017-12-20T08:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始工作了，为了配合队友，得写 Objective-C。写 Objective-C 的时候，有一个糟心的地方就是定义一个变量的时候：写下一个变量之前，首先映入我的脑海的是如何优雅地命名这个变量，但我却要先写它的类型；而且这个类型还经常需要写两遍，当这种重复的事情做多了，很容易烦躁起来；还有那个星号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *anElegantView = [<span class="built_in">UIView</span> new];</span><br><span class="line">WaitASecICantRememberThatRightNow *something = array.firstObject;</span><br></pre></td></tr></table></figure><a id="more"></a><p>所幸的是，从 PSPDFKit 团队的文章 <a href="https://pspdfkit.com/blog/2017/even-swiftier-objective-c/">Even Swiftier Objective-C</a> 中可以得知，原来苹果在不知道什么时候给 Objective-C 带来了类型推导，现在我们可以将上面的代码写成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__auto_type anElegantView = [<span class="built_in">UIView</span> new];</span><br><span class="line">__auto_type something = (TheType *)array.firstObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 array 使用了 lightweight generics </span></span><br><span class="line">__auto_type something = array.firstObject;</span><br></pre></td></tr></table></figure><p>这下写法总算和 Swift 相似了一些。PSPDFKit 团队没有停下脚步，又定义了一些宏。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define let __auto_type const</span></span><br><span class="line"><span class="meta">#define var __auto_type </span></span><br><span class="line"></span><br><span class="line">let anElegantView = [<span class="built_in">UIView</span> new];</span><br><span class="line">let something = (TheType *)array.firstObject;</span><br><span class="line">var something = array.firstObject;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anElegantView = <span class="type">UIView</span>()</span><br><span class="line"><span class="keyword">let</span> something: <span class="type">TheType</span> = array.first</span><br><span class="line"><span class="keyword">var</span> something = array.first</span><br></pre></td></tr></table></figure><p>再给 <code>NSArray</code> 和 <code>NSMutableArray</code> 加上 <code>map filter</code> 那些，一下子觉得舒服多了。更多更详细的骚操作请看他们的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始工作了，为了配合队友，得写 Objective-C。写 Objective-C 的时候，有一个糟心的地方就是定义一个变量的时候：写下一个变量之前，首先映入我的脑海的是如何优雅地命名这个变量，但我却要先写它的类型；而且这个类型还经常需要写两遍，当这种重复的事情做多了，很容易烦躁起来；还有那个星号。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *anElegantView = [&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WaitASecICantRememberThatRightNow *something = array.firstObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://intii.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>也可以这样展示书籍封面？</title>
    <link href="http://intii.com/2017/a-better-way-to-display-a-book-cover-questionmark/"/>
    <id>http://intii.com/2017/a-better-way-to-display-a-book-cover-questionmark/</id>
    <published>2017-04-28T14:30:13.000Z</published>
    <updated>2018-11-25T14:18:57.431Z</updated>
    
    <content type="html"><![CDATA[<p>上周赶着要交一个作业，原本是想着开新的项目写一部分交上去的，后来进度太糟糕，就打算另辟蹊径。只剩下几天时间，偶然看 Dribbble 的时候看到了一个豆瓣图书的客户端，觉得要不写个扫码获取书本资料的 app 吧，简单，又符合题意，又能顺便写写 Objective-C 练习一下，便以 <code>Book Shelf</code> 为关键词在 Dribbble 上搜索一番，发现<a href="https://dribbble.com/shots/3116835-Bookshelf">有个设计</a>很棒。它展示的书籍封面是立体的，打开大图仔细一看，发现事情没有那么简单，看起来像是在一张平面的封面上，切了角，打了高光加了阴影，却高大上了许多。</p><p>先是在 Sketch 里面试了试。</p><object class="svg" style="width: 100%;" data="/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.svg" type="image/svg+xml"><br>  <img src="/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.png" /><br></object><a id="more"></a><p>具体实现简单粗暴，就是<a href="https://github.com/int123c/StallApp/blob/master/Stall/BookView.m">上面罩了一堆 <code>CALayer</code></a>（</p><p>具体效果：<br><img src="/media/a-better-way-to-display-a-book-cover-questionmark/IMG_2204.png" style="width:400px;" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周赶着要交一个作业，原本是想着开新的项目写一部分交上去的，后来进度太糟糕，就打算另辟蹊径。只剩下几天时间，偶然看 Dribbble 的时候看到了一个豆瓣图书的客户端，觉得要不写个扫码获取书本资料的 app 吧，简单，又符合题意，又能顺便写写 Objective-C 练习一下，便以 &lt;code&gt;Book Shelf&lt;/code&gt; 为关键词在 Dribbble 上搜索一番，发现&lt;a href=&quot;https://dribbble.com/shots/3116835-Bookshelf&quot;&gt;有个设计&lt;/a&gt;很棒。它展示的书籍封面是立体的，打开大图仔细一看，发现事情没有那么简单，看起来像是在一张平面的封面上，切了角，打了高光加了阴影，却高大上了许多。&lt;/p&gt;
&lt;p&gt;先是在 Sketch 里面试了试。&lt;/p&gt;
&lt;object class=&quot;svg&quot; style=&quot;width: 100%;&quot; data=&quot;/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;br&gt;  &lt;img src=&quot;/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.png&quot; /&gt;&lt;br&gt;&lt;/object&gt;
    
    </summary>
    
    
      <category term="Design" scheme="http://intii.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>新头像，盾斧使</title>
    <link href="http://intii.com/2017/new-avatar-charge-blade-master/"/>
    <id>http://intii.com/2017/new-avatar-charge-blade-master/</id>
    <published>2017-03-08T10:21:31.000Z</published>
    <updated>2017-04-27T04:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>还有十天 MHXX 就要发售了，非常地期待，于是最近坐火车的时候都会掏出 3DS 来玩玩 MHX。MHX 里面最喜欢的武器还是盾斧，刚开始玩的时候用的都是武士道风格，最近试了试强袭风格，觉得还是挺不错的。</p><p>这次的头像参考了某雌火龙套装 + 盾斧的手办，虽然只带了头盔，<del>但居然也是女装哦</del>。武器看起来是工会盾斧，没有认真画，歪七扭八的。<br><a id="more"></a></p><p><img src="/media/avatar-charge-blade-master.jpg" alt="avatar-charge-blade-maste"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还有十天 MHXX 就要发售了，非常地期待，于是最近坐火车的时候都会掏出 3DS 来玩玩 MHX。MHX 里面最喜欢的武器还是盾斧，刚开始玩的时候用的都是武士道风格，最近试了试强袭风格，觉得还是挺不错的。&lt;/p&gt;
&lt;p&gt;这次的头像参考了某雌火龙套装 + 盾斧的手办，虽然只带了头盔，&lt;del&gt;但居然也是女装哦&lt;/del&gt;。武器看起来是工会盾斧，没有认真画，歪七扭八的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>将豆瓣收藏保存到 Day One 的一个正确方式</title>
    <link href="http://intii.com/2017/saving-douban-fav-to-dayone-the-correct-way/"/>
    <id>http://intii.com/2017/saving-douban-fav-to-dayone-the-correct-way/</id>
    <published>2017-01-23T15:30:52.000Z</published>
    <updated>2017-01-24T06:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道豆瓣是怎么考虑的，豆瓣收藏的 RSS 并没有给出电影海报／书封面的大图，每次看到 Day One 里存了的那张迷你海报就不舒服( ･᷄ὢ･᷅ )。有一个曲线救国的方式是将豆瓣收藏同步到新浪微博，再用 IFTTT 将新浪微博同步到 Day One 里。然而我不用新浪微博很久了，突然在上面发些什么东西总觉得有些不妥，而且这个方法要求在收藏的时候添加一个 tag 以区别它们与其它微博，不够干爽。</p><p>突然今天看到<a href="http://www.appinn.com/integromat/">小众软件推荐了 Integromat</a>，这个产品类似于 IFTTT，但能串联很多任务，甚至包括了正则表达式匹配，再配合 IFTTT 就能将拥有大图的豆瓣收藏保存到 Day One 里了。</p><a id="more"></a><p>豆瓣开放给任意人使用的电影／图书信息 API 里并没有包含大图的链接，但仔细看能够发现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 电影</span><br><span class="line">img3.doubanio.com/view/movie_poster_cover/ipst/public/p2391300344.jpg // 小图</span><br><span class="line">img3.doubanio.com/view/movie_poster_cover/lpst/public/p2391300344.jpg // 大图</span><br><span class="line"></span><br><span class="line">// 图书</span><br><span class="line">img3.doubanio.com/spic/s28416025.jpg // 小图</span><br><span class="line">img3.doubanio.com/lpic/s28416025.jpg // 大图</span><br></pre></td></tr></table></figure><p>不就差了一个字母而已嘛可恶。你看到是哪个字母了吗可恶。</p><p>所以只需要在 Integromat 里用正则表达式匹配前后两部分再拼起来再利用 IFTTT Maker channel 发送到 Day One 就可以了。简直浪费人生。</p><p><del>Integromat 的客服不错，之前我正则表达式写错了他们还帮我改好了（</del></p><p>干这种事情用免费版就足够了。</p><p><img src="http://o7kolop30.bkt.clouddn.com/Screen Shot 2017-01-23 at 11.28.29 PM-1.png" alt="Scenario in Integromat"></p><p>最后终于能看到大图啦好高兴。</p><p><img src="http://o7kolop30.bkt.clouddn.com/Screen Shot 2017-01-23 at 11.24.32 PM.png" alt="Douban Fav with Large Album Picture"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道豆瓣是怎么考虑的，豆瓣收藏的 RSS 并没有给出电影海报／书封面的大图，每次看到 Day One 里存了的那张迷你海报就不舒服( ･᷄ὢ･᷅ )。有一个曲线救国的方式是将豆瓣收藏同步到新浪微博，再用 IFTTT 将新浪微博同步到 Day One 里。然而我不用新浪微博很久了，突然在上面发些什么东西总觉得有些不妥，而且这个方法要求在收藏的时候添加一个 tag 以区别它们与其它微博，不够干爽。&lt;/p&gt;
&lt;p&gt;突然今天看到&lt;a href=&quot;http://www.appinn.com/integromat/&quot;&gt;小众软件推荐了 Integromat&lt;/a&gt;，这个产品类似于 IFTTT，但能串联很多任务，甚至包括了正则表达式匹配，再配合 IFTTT 就能将拥有大图的豆瓣收藏保存到 Day One 里了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 年总结</title>
    <link href="http://intii.com/2016/summary-of-2016/"/>
    <id>http://intii.com/2016/summary-of-2016/</id>
    <published>2016-12-30T13:37:32.000Z</published>
    <updated>2016-12-30T15:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如同往常一样，今年定下了很多目标，达成了没几个，很多遗憾。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如同往常一样，今年定下了很多目标，达成了没几个，很多遗憾。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新头像，Explosion</title>
    <link href="http://intii.com/2016/avatar-megumin-explosion/"/>
    <id>http://intii.com/2016/avatar-megumin-explosion/</id>
    <published>2016-12-20T15:02:40.000Z</published>
    <updated>2016-12-30T15:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了庆祝《为美好的世界献上祝福》第二季即将在一月开播，所以做了个惠惠版的头像。想要加入一些动作，头像主要参考了惠惠官方粘土人的宣传画。惠惠真是太棒了。<br><a id="more"></a></p><p><img src="/media/avatar-megumin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了庆祝《为美好的世界献上祝福》第二季即将在一月开播，所以做了个惠惠版的头像。想要加入一些动作，头像主要参考了惠惠官方粘土人的宣传画。惠惠真是太棒了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新头像，从寨大毕业</title>
    <link href="http://intii.com/2016/avatar-graduation-2016/"/>
    <id>http://intii.com/2016/avatar-graduation-2016/</id>
    <published>2016-04-18T11:58:45.000Z</published>
    <updated>2016-12-27T13:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>一不小心，就要从寨大毕业了。</p><a id="more"></a><p><img src="/media/avatar-graduation-2016.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一不小心，就要从寨大毕业了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新头像，圣诞节</title>
    <link href="http://intii.com/2015/avatar-christmas-2015/"/>
    <id>http://intii.com/2015/avatar-christmas-2015/</id>
    <published>2015-12-04T06:19:51.000Z</published>
    <updated>2017-04-27T04:22:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>圣诞节。<br><a id="more"></a><br><img src="/media/avatar-christmas-2015.jpg" alt="avatar-christmas-2015"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;圣诞节。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>公选课攻略：中西方美术鉴赏、认识肿瘤</title>
    <link href="http://intii.com/2015/public-course-walkthroughs-in-szu-s6/"/>
    <id>http://intii.com/2015/public-course-walkthroughs-in-szu-s6/</id>
    <published>2015-07-18T08:16:59.000Z</published>
    <updated>2016-12-25T09:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>总算到了大三的最后一个学期。因为懒我在大二的下学期一个公选课也没选，导致我这学期还得再修个 4 分才够毕业，在别人可能都只修了 10 分左右的大三下学期，我顶着 19 分的压力，还真是不好受，更别说这学期还考砸了，小看了某一科导致又拿了个 C，然后某一科居然给我了个 B，简直是无语……</p><p>不过也多亏了这 4 分，我得以在认识肿瘤的课上重遇了小学前期的同桌吴同学，虽然没好意思去打招呼，但还是很高兴的。</p><p>这学期的两门公选课的结果是，中西方美术鉴赏：B，认识肿瘤：A。</p><a id="more"></a><h2 id="中西方美术鉴赏"><a href="#中西方美术鉴赏" class="headerlink" title="中西方美术鉴赏"></a>中西方美术鉴赏</h2><p>鉴赏类课程是深大公选课中的热门课程，同一个系列的还有电影欣赏之类的看名字就知道是混着就能过的课程。但是，万万没想到，中西方美术鉴赏其实是这学期才开的一门新课，有大量美院的学生来凑热闹，论相关知识你不如他们，论与老师的关系你也不如他们，因此想得 A 还是比想象中的要难。</p><p>课程由 3 个老师负责，每人大概各有 6 周的样子，分别讲的是油画、雕塑和版画，前两个老师偶尔会点名，但版画的老师几乎是每次都点名。中途没有作业，所以相对还是很轻松的。上课会关灯，所以做不了作业，玩手机也很显眼。期末考试是课下写一篇 1,000 - 1,500 字的作品鉴赏，三个老师会各自选择一些相关的作品供学生选择，学生只需从所有作品中选择一个来写就可以了。这次给的作品中，油画给的貌似有一幅是课上讲过的，其它因为我没听课所以不清楚，而版画给的似乎都没有在课上出现过。</p><p>另外，大家选的貌似都是油画，所以油画的分数可能会相对较低哦……</p><p>作业在学期最后一节课提交，但最后一节课貌似还是要上的，虽然我翘掉了。</p><h2 id="认识肿瘤"><a href="#认识肿瘤" class="headerlink" title="认识肿瘤"></a>认识肿瘤</h2><p>教室宽敞明亮，是一门用来赶作业的好课（，这个课也是好多个老师一起讲，期末考试以开卷考试的形式进行，题目比较简单基本都能在 PPT 里面找到，但也别高兴的太早，因为这个课有十几个 PPT，每个又有七八十页，光是打印就得打印好多页，也正因如此我学会了如何正确的使用我家的打印机进行双面打印。</p><p>考试在最后一节课进行，考试前建议先预习一下，否则要在这么多张纸里面找到答案还是很困难的。该预习什么呢，至少得熟悉一下人体的各个器官属于什么系统吧，不要像我这样搞不清肝是什么系统的导致找不到答案。然后了解一下 PPT 是怎么安排的，比如说介绍一个具体的肿瘤，会先讲症状最后会讲预后什么的。至于打印的时候，为了省纸省墨，大可讲所有英文部分删去，图片也基本不需要留。</p><p>截至这学期，我已经修了现代教学论（文科学分）、产品设计欣赏（文科学分）、茶叶品鉴（理科学分）、积极心理学（文科学分）、中西方美术鉴赏（文科学分）、认识肿瘤（理科学分）共六门公选课，12 个学分（含 8 分文科学分），也就是说已经足够啦啦啦／</p><p>预祝抢课愉快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总算到了大三的最后一个学期。因为懒我在大二的下学期一个公选课也没选，导致我这学期还得再修个 4 分才够毕业，在别人可能都只修了 10 分左右的大三下学期，我顶着 19 分的压力，还真是不好受，更别说这学期还考砸了，小看了某一科导致又拿了个 C，然后某一科居然给我了个 B，简直是无语……&lt;/p&gt;
&lt;p&gt;不过也多亏了这 4 分，我得以在认识肿瘤的课上重遇了小学前期的同桌吴同学，虽然没好意思去打招呼，但还是很高兴的。&lt;/p&gt;
&lt;p&gt;这学期的两门公选课的结果是，中西方美术鉴赏：B，认识肿瘤：A。&lt;/p&gt;
    
    </summary>
    
      <category term="Essay" scheme="http://intii.com/categories/Essay/"/>
    
    
      <category term="深圳大学" scheme="http://intii.com/tags/%E6%B7%B1%E5%9C%B3%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>公选课攻略：茶叶品鉴、积极心理学</title>
    <link href="http://intii.com/2015/public-course-walkthroughs-in-szu-s5/"/>
    <id>http://intii.com/2015/public-course-walkthroughs-in-szu-s5/</id>
    <published>2015-01-28T13:04:57.000Z</published>
    <updated>2018-11-25T14:26:36.571Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/public-course-walkthroughs-in-szu-s5/TeaAndBrainsum.jpg" alt=""></p><p>早上起来看了下番然后发现出成绩了，因为本来就没有什么期望所以心情还算比较淡定，查询的人不多，一下子成绩就出来了，然后发现专业课都是 A，只有这两个公选课拖了我的后腿。茶叶品鉴拿了 B，积极心理学拿了 C……果然热门课不靠谱。</p><a id="more"></a><h2 id="茶叶品鉴"><a href="#茶叶品鉴" class="headerlink" title="茶叶品鉴"></a>茶叶品鉴</h2><p>茶叶品鉴绝对是个热门课啊，抢了几个学期才让我抢到了，直到我去上了这门课才发现上当了。这门课每节课上半节会讲很无聊的茶叶知识，偶尔老师会吹吹自己有多文艺带着古琴去旅游，然后晒晒自己过曝没构图没对焦的照片……然后下半节课让学生自己泡茶聊天。然后有一节课会讲著名伪科学实验水＊＊的＊密（太羞耻了我都不好意思把六个字都打出来），真个老师虽然是个法学院的老师，却坚信人类能够发功改变茶的味道(´･ω･｀)。接下来是攻略。</p><p>虽然不会点名，但是座位是在第二节课之后就固定下来的，所以不排除老师会自己解决签到的问题。前几节课会要求写品茶<strong>感悟</strong>，看到了吗「感悟」 加粗了哦，意思是茶的部分不重要，重要是得好好的写感悟才能有高分哦 。总共要写五次。</p><p>之后会布置一个课外的实践，要求组队，在 17 周之前完成，并写好实验报告或论文。在这里建议选择论文形式的实践，因为论文不要求图文并茂却在字数要求上只比实验报告多 500 个字。</p><p>中间会有一次期中考试，考的是泡茶的操作，考试前前一节课老师会演示一遍，考试前好像也会。大概会有三个老师监考，其中两个同时监考两个人，一个只监考一个人，监考两个人的老师可能会无视其中一个学生然后淡定的给出一个低分。</p><p>中途讲到的所有知识都是没有必要记下的，因为期末考试不会去考这些。期末考试分为两部分，第一部分是老师给出 5 种茶叶，学生写出茶叶的名字；第二部分是老师泡 5 种茶，学生喝了之后写出茶的名字。这些茶都是在每节课的后半节喝过的。不过完全无须为这个考试担心，因为这是开卷开手机能讨论的(๑‾ ꇴ ‾๑)</p><h2 id="积极心理学"><a href="#积极心理学" class="headerlink" title="积极心理学"></a>积极心理学</h2><p>下学期的选课里这门课貌似只剩下 MOOC 的版本了，MOOC 版本还要求考试，所以要是想混的话不推荐。</p><p>如果还能够选到常规版本的话，这课应该还是不错的，有几个老师讲课十分风趣。期末要求交一篇 5,000 字的论文，题目为上课时讲过的题目任选，根据 MOOC 版本的要求，应该是要写比较正式的那种论文，期末前两周交。中途只有几个老师会点名，也只是抽着点，没有作业，座位舒适，没有著名伪科学实验。</p><p>&nbsp;</p><p>预祝抢课愉快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/public-course-walkthroughs-in-szu-s5/TeaAndBrainsum.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;早上起来看了下番然后发现出成绩了，因为本来就没有什么期望所以心情还算比较淡定，查询的人不多，一下子成绩就出来了，然后发现专业课都是 A，只有这两个公选课拖了我的后腿。茶叶品鉴拿了 B，积极心理学拿了 C……果然热门课不靠谱。&lt;/p&gt;
    
    </summary>
    
      <category term="Essay" scheme="http://intii.com/categories/Essay/"/>
    
    
      <category term="深圳大学" scheme="http://intii.com/tags/%E6%B7%B1%E5%9C%B3%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>煮呀嘛煮咖啡</title>
    <link href="http://intii.com/2014/make-coffee-with-moka-pot/"/>
    <id>http://intii.com/2014/make-coffee-with-moka-pot/</id>
    <published>2014-09-02T15:24:58.000Z</published>
    <updated>2018-11-25T14:26:07.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/make-coffee-with-moka-pot/Tools-2-4px.jpg" alt=""></p><p><strong>2015-5-7：这家伙已经将摩卡壶扔进了柜子里，换用 Minipresso 了。</strong></p><p>之前因为买了个新杯子（虽然后来又换了个），突然想自己做咖啡喝，为了让这个决定更安全一些，买了一包粉还有一个法压壶，但法压壶也就只能泡泡单品咖啡，我还是比较喜欢加好多牛奶的那种。考虑了很久最后决定买个摩卡壶，然后一不小心又买了打奶壶和磨豆君，还换了个新杯子，开始了自己煮咖啡。</p><a id="more"></a><p>摩卡壶有好多种，最后为了有逼格又不砸钱，入了个比乐蒂的四人份的单阀<a href="http://www.bialetti.com/www.bialetti.com/coffee/stovetop/moka-express-c-1_7_22.html?zenid=3ec5612qe7488ig7d78l2gt9e1">八角摩卡壶</a>，但毕竟没有意式机出的咖啡那么正宗呢，虽然自己喝还是不错的，全手动的体验也挺有趣，就是比较耗时。我也不是没有考虑过意式机，甚至也去试过胶囊机……但是……</p><p><img src="/media/make-coffee-with-moka-pot/Machines-2-4px.jpg" alt=""></p><p>但是真他娘亲的贵……胶囊机最少也得一千多吧，虽然相当方便，但没<del>逼格</del>意思，还是自己手动的好玩。而意式机呢，据说一千以下全都是玩具，入门推荐款也得一千六。而且意式机是个大坑啊，买了之后还得买个好的电动磨豆君，实在玩不起。于是咱还是踏踏实实的玩摩卡壶嗯。</p><p>网上的摩卡壶使用教程们的细节都很模糊，大火小火不知道到底是多大，加多少水也没有个确定的说法，什么时候关火、什么时候要大/小火也各执一词，但经过这些天的尝试，我觉得我做的还是挺好喝的（</p><p>我觉得用摩卡壶煮咖啡，首先得要有一包还不错的做 Espresso 的豆子。之前随手买了一包深度烘焙的粉，煮出来简直要苦死，加了奶还是像中药一样(´･ω･｀) 后来换了 <a href="http://www.amazon.cn/ILLY意利咖啡豆-250g/dp/B000VOCQPW/ref=sr_1_2?ie=UTF8&amp;qid=1409739550&amp;sr=8-2&amp;keywords=illy">illy</a> 的豆子，好喝了不少。根据摩卡壶的原理，加水不要超过气阀（除非想看爆炸），我一般都加到气阀以下大概一厘米的地方，出水大概小半杯的样子（我的杯子大概 300 mL），看心情加不要太多不要太少就好。有人说一开始加热水能防止过度萃取，反正我是这么干的，没有比较过，随意就好。按道理讲粉应该放满粉碗才好，但我比较省一般才放 16 g 左右（主要是磨得累），粉铺平，不要压，装好拧紧就能开始煮了。</p><p><img src="/media/make-coffee-with-moka-pot/Moka-Pot-2-4px.jpg" alt=""></p><p>煮的时候火不要超过壶底防止把壶烧坏了，等到流出的咖啡颜色变淡，或者你觉得咖啡出的差不多了，就可以关火了。网上有人建议关火后把壶放到湿布上降温，可以防止过度萃取。</p><p>综上所述就是 Follow your heart，想怎么煮怎么煮，煮坏了下次换一种方式，反正有“自己给自己做的肯定会好吃/喝”这种 buff。</p><p>在煮咖啡的过程中就可以打奶泡了。</p><p><img src="/media/make-coffee-with-moka-pot/Prepare-Milk-2-4px.jpg" alt=""></p><p>手打奶泡要先将牛奶加热到 60°C - 70°C（我会说我手贱买了个华氏度温度计吗），然后拼命地打，最后将最上层的大气泡们刮走，奶泡就好了。准备好杯子（我会在里面放一颗方糖），淋入咖啡，用小勺挡住打奶壶的口先将下层的牛奶倒入，最后倒入奶泡，一杯咖啡就完成了！</p><p>为了不浪费牛奶，可以用奶粉哦。然后法压壶被我拿去泡茶了。等我玩厌了再想想看要不要跟母上申请一台胶囊机（意式机坑太深就算了）。</p><p>不说了我的摩卡壶好像还没洗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/media/make-coffee-with-moka-pot/Tools-2-4px.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2015-5-7：这家伙已经将摩卡壶扔进了柜子里，换用 Minipresso 了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前因为买了个新杯子（虽然后来又换了个），突然想自己做咖啡喝，为了让这个决定更安全一些，买了一包粉还有一个法压壶，但法压壶也就只能泡泡单品咖啡，我还是比较喜欢加好多牛奶的那种。考虑了很久最后决定买个摩卡壶，然后一不小心又买了打奶壶和磨豆君，还换了个新杯子，开始了自己煮咖啡。&lt;/p&gt;
    
    </summary>
    
      <category term="Essay" scheme="http://intii.com/categories/Essay/"/>
    
    
      <category term="coffee" scheme="http://intii.com/tags/coffee/"/>
    
      <category term="咖啡" scheme="http://intii.com/tags/%E5%92%96%E5%95%A1/"/>
    
      <category term="摩卡壶" scheme="http://intii.com/tags/%E6%91%A9%E5%8D%A1%E5%A3%B6/"/>
    
  </entry>
  
</feed>
