<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>INTITNI BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://intii.com/"/>
  <updated>2019-09-13T01:48:04.356Z</updated>
  <id>http://intii.com/</id>
  
  <author>
    <name>Shangxin Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 Function Builder 来简化 Auto Layout</title>
    <link href="http://intii.com/2019/simplify-auto-layout-constraints-with-function-builder/"/>
    <id>http://intii.com/2019/simplify-auto-layout-constraints-with-function-builder/</id>
    <published>2019-09-12T06:30:00.000Z</published>
    <updated>2019-09-13T01:48:04.356Z</updated>
    
    <content type="html"><![CDATA[<p>尽管用代码来写 layout constraint 已经比以前要简单许多了，但是还是有一些麻烦的地方。一个简单的例子就是很多第三方布局库都会提供一些这样的写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.snp.makeConstraints &#123; make <span class="keyword">in</span></span><br><span class="line">    make.center.equalTo(bar)</span><br><span class="line">    make.width.equalTo(<span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 layout anchor 来写的话，就需要三行了： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">    foo.centerXAnchor.constraint(equalTo: bar.centerXAnchor),</span><br><span class="line">    foo.centerYAnchor.constraint(equalTo: bar.centerYAnchor),</span><br><span class="line">    foo.widthAnchor.constraint(equalToConstant: <span class="number">12</span>) </span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>倒也不是没有办法优化，比如说我们可以给 <code>UIView</code> 增加一个方法直接返回居中相关的两个约束，但最终的写出来却还是很奇怪：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLayoutConstraint</span>.activate(</span><br><span class="line">    [foo.widthAnchor.constraint(equalToConstant: <span class="number">12</span>)]</span><br><span class="line">    + foo.constraintsToCenter(<span class="keyword">in</span>: bar)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个时候 function builder 横空出世了。它能让我们将一连串可以转化为一组 <code>NSLayoutConstraint</code> 的表达式串联写在 block 里面，最终 function builder 会将这些表达式合成为一个 <code>[NSLayoutConstraint]</code>，我们可以定义一个 protocol <code>LayoutConstraintBuildUp</code> 来代表这些表达式，它们会在 function builder 的 <code>buildBlock</code> 方法中被合并成为一个 <code>[NSLayoutConstraint]</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LayoutConstraintBuildUp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">buildUp</span><span class="params">()</span></span> -&gt; [<span class="type">LayoutConstraintBuildUp</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@_functionBuilder</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutConstraintBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span><span class="params">(<span class="number">_</span> children: LayoutConstraintBuildUp...)</span></span> -&gt; [<span class="type">LayoutConstraintBuildUp</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> children.<span class="built_in">map</span> &#123; $<span class="number">0</span>.buildUp() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们就可以为 <code>NSLayoutConstraint</code> 增加一个方法，让其能够接受一个 function builder 作为参数构建约束。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSLayoutConstraint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">activate</span><span class="params">(@LayoutConstraintBuilder <span class="number">_</span> constraints: <span class="params">()</span></span></span> -&gt; [<span class="type">LayoutConstraintBuildUp</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> all = constraints().flatMap &#123; $<span class="number">0</span>.buildUp() &#125;</span><br><span class="line">        activate(all)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate &#123;</span><br><span class="line">    foo.widthAnchor.constraint(equalToConstant: <span class="number">12</span>)</span><br><span class="line">    foo.constraintsToCenter(<span class="keyword">in</span>: bar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许你觉得这样写还不够简单，那不妨考虑一下用自定义的运算符来代替单个约束的创建，比如说这样 <code>foo.widthAnchor =&gt; 12</code>。这样一来像是 SnapKit 这样的第三方布局库就不见得有什么优势了，能够用原生的话，当然还是原生的好。</p><p>然而 function builder 甚至还没进入 review 阶段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管用代码来写 layout constraint 已经比以前要简单许多了，但是还是有一些麻烦的地方。一个简单的例子就是很多第三方布局库都会提供一些这样的写法：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;foo.snp.makeConstraints &amp;#123; make &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    make.center.equalTo(bar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    make.width.equalTo(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果用 layout anchor 来写的话，就需要三行了： &lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;NSLayoutConstraint&lt;/span&gt;.activate([&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo.centerXAnchor.constraint(equalTo: bar.centerXAnchor),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo.centerYAnchor.constraint(equalTo: bar.centerYAnchor),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo.widthAnchor.constraint(equalToConstant: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;倒也不是没有办法优化，比如说我们可以给 &lt;code&gt;UIView&lt;/code&gt; 增加一个方法直接返回居中相关的两个约束，但最终的写出来却还是很奇怪：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;NSLayoutConstraint&lt;/span&gt;.activate(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [foo.widthAnchor.constraint(equalToConstant: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    + foo.constraintsToCenter(&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;: bar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://intii.com/tags/Xcode/"/>
    
      <category term="Layout Constraint" scheme="http://intii.com/tags/Layout-Constraint/"/>
    
      <category term="Function Builder" scheme="http://intii.com/tags/Function-Builder/"/>
    
  </entry>
  
  <entry>
    <title>新头像，一拳超人</title>
    <link href="http://intii.com/2019/avatar-one-punch-man-2019/"/>
    <id>http://intii.com/2019/avatar-one-punch-man-2019/</id>
    <published>2019-04-22T10:21:31.000Z</published>
    <updated>2019-07-24T14:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>原本其实想画只狼的，后来觉得忍义手好麻烦，就只好一拳超人了（<br><a id="more"></a><br><img src="/media/avatar-one-punch-man-2019.PNG" alt="avatar-one-punch-man"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原本其实想画只狼的，后来觉得忍义手好麻烦，就只好一拳超人了（&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>稍微有点响应式编程</title>
    <link href="http://intii.com/2019/write-code-not-that-reactively/"/>
    <id>http://intii.com/2019/write-code-not-that-reactively/</id>
    <published>2019-03-13T12:30:00.000Z</published>
    <updated>2019-03-14T16:48:07.672Z</updated>
    
    <content type="html"><![CDATA[<p>一开始我其实只是想用 KVO 让 View Model 更响应式一些，可是 KVO 只支持 NSObject，用起来绑手绑脚，感觉没法进行下去。以前看过一些响应式的代码，想要模仿一下它们的风格。感觉要是有这么两个类型就好了：</p><ol><li><code>Observable&lt;T&gt;</code>，它内部持有一个变量，当这个变量发生改变时，通知其观察者。</li><li><code>Emitter&lt;T&gt;</code>，当 ViewModel 发生了什么需要告知 ViewController 时，可以通过 <code>Emitter</code> 发送一个事件，通知其所有的观察者。</li></ol><p>譬如说我们要写一个掷骰子的程序，这个程序最奇特的一处是当我们多次掷到的数字之和超过 36，就会弹出一个弹窗告诉我们掷到了 36。我们的 ViewModel 可以这样子写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> thirtySix = <span class="type">Emitter</span>&lt;<span class="type">Void</span>&gt;(())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newNum = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">6</span>)</span><br><span class="line">        num.val = newNum</span><br><span class="line">        sum += newNum</span><br><span class="line">        <span class="keyword">if</span> sum &gt;= <span class="number">36</span> &#123; thirtySix.emit(()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如此一来 ViewController 就可以通过监听 <code>num</code> 现实当前掷到的数字和 <code>thirtySix</code> 来得知应该合适显示弹窗了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> viewModel = <span class="type">ViewModel</span>()</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        viewModel.num.subscribe &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] num <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.label.text = <span class="string">"<span class="subst">\(num)</span>"</span></span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        viewModel.thirtySix.subscribe &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.alert()</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就如同 KVO 那样，我们监听之后，总需要有个什么东西持有这个 block，自然而然的，我们就需要这个东西能够在恰当的时候被释放，这样 block 就不会一直被执行了。像各种各样的响应式框架那样，这种东西应该被叫做 <code>Disposable</code>，它有一个 <code>dispose</code> 方法，能够消除监听效果。</p><p>说起 KVO，我们不妨用 <code>Disposable</code> 包装一下 <code>NSKeyValueObservation</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObjectProtocol</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;V&gt;<span class="params">(<span class="number">_</span> keyPath: KeyPath&lt;<span class="keyword">Self</span>, V&gt;, onChange: @escaping <span class="params">(V, V?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> observation = observe(keyPath, options: [.initial, .new]) &#123; <span class="number">_</span>, change <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newValue = change.newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            onChange(newValue, change.oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span> &#123; observation.invalidate() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写着写着我们就大概清楚 <code>Disposable</code> 应该如何实现了。而且 <code>Disposable</code> 不仅具有取消监听的作用，它还持有了 <code>NSKeyValueObservation</code> 的强引用，也就是说只要我们持有了 <code>Disposable</code>，也就自然持有了 <code>NSKeyValueObservation</code>。同样的道理，我们也可以将 <code>UIControl</code> 的 <code>addTarget</code> 或者 <code>NotificationCenter</code> 通过这种方式进行监听，这样我们就能通过 <code>DisposeBag</code> 统一管理了。</p><p>那属于 <code>Observable&lt;V&gt;</code> 和 <code>Emitter&lt;V&gt;</code> 的 <code>NSKeyValueObservation</code> 又是什么呢？在这里我们就再引入一个类吧。姑且叫它 <code>Observation&lt;V&gt;</code> 吧。</p><p>对于一个 <code>Observation</code>，它可以接受一个事件 <code>Event</code>，并将这个 <code>Event</code> 传递给 subscriber。事件的定义很简单，它既可以是一个新值，也可以是一次错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">V</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observation</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PossibleEvent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> next</span><br><span class="line">        <span class="keyword">case</span> failure</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> observers = [(<span class="type">String</span>, (<span class="type">Event</span>) -&gt; <span class="type">Void</span>)]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> latestEvent: <span class="type">Event</span>&lt;<span class="type">V</span>&gt;? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">deinit</span> &#123; disposeBag.dispose() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="number">_</span> event: Event&lt;V&gt;)</span></span> &#123;</span><br><span class="line">        observers.forEach &#123; $<span class="number">0.1</span>(event) &#125;</span><br><span class="line">        latestEvent = event</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribeEvent</span><span class="params">(perform block: @escaping <span class="params">(Event)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> uuid = <span class="type">UUID</span>().uuidString</span><br><span class="line">        observers.append((uuid, block))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> e = latestEvent &#123; block(e) &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span> &#123; [uuid] <span class="keyword">in</span> <span class="keyword">self</span>.observers.removeAll(<span class="keyword">where</span>: &#123; $<span class="number">0.0</span> == uuid &#125;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>subscribeEvent</code> 方法我们可以注册订阅 <code>Observation</code> 的事件，每次注册订阅之后我们将传入的 <code>block</code> 保存到 <code>observers</code> 当中，我们给每一个 <code>block</code> 一个 UUID，这样我们就能够在 <code>dispose</code> 的时候准确的删掉不需要的 <code>block</code>。</p><p>其实更多的时候，我们才不在乎什么错误！所以可以加上这个么一个方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(onNext: @escaping <span class="params">(V)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subscribeEvent &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .next(v) = event &#123; onNext(v) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉不错。现在只剩下一个问题了，我们要如何创建一个 <code>Observation&lt;V&gt;</code> 呢？不妨再用 KVO 套一下。要生成一个监听 KVO 的 <code>Observation&lt;V&gt;</code>，我们就需要把 <code>Observation&lt;V&gt;</code> 订阅以及取消订阅 KVO 的逻辑教导给 <code>Observation&lt;V&gt;</code>。我们可以在初始化的时候进行这个步骤：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(observeBlock: (<span class="type">Observation</span>) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">    observeBlock(<span class="keyword">self</span>).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以把 KVO 订阅写成这样了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">observe</span>&lt;V&gt;<span class="params">(<span class="number">_</span> keyPath: KeyPath&lt;<span class="keyword">Self</span>, V&gt;)</span></span> -&gt; <span class="type">Observation</span>&lt;<span class="type">V</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(keyPath) &#123; new, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            observation.action(.next(new))</span><br><span class="line">        &#125; <span class="comment">// 一个 Disposable &#123; keyValueObservation.invalidate() &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化的过程中，<code>observationBlock</code> 会被调用并生成一个 <code>Disposable</code>，一旦 KVO 触发，<code>Observation</code> 就会接收到一个新值事件，而这个事件则会继续传递给 <code>Observation</code> 的观察者们。<code>Disposable</code> 有 <code>Observation</code> 负责管理，这样子一旦 <code>Observation</code> 被释放，对应的 KVO 订阅也会被释放。</p><p>但这里还有一个问题，在 <code>observeBlock</code> 中我们传入了 <code>Observation</code> 自身，而它在 block 内部又被 <code>subscribe</code> 的 block 给捕获了，如此产生的 <code>Disposable</code> 又返回给了 <code>Observation</code> 自己持有。铛铛铛，引用循环出现了。为了跳出这个圈，我们可以在 <code>subscribe</code> 的时候弱捕获 <code>Observation</code>，但这样很容易犯错，所以可以选择写一个 Wrapper 包住它。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakObservation</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> observation: <span class="type">Observation</span>&lt;<span class="type">V</span>&gt;?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(observeBlock: (<span class="type">WeakObservation</span>) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">    observeBlock(<span class="type">WeakObservation</span>(<span class="keyword">self</span>)).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来就清晰多了。</p><p>首先要做的是给 <code>Emitter</code> 和 <code>Observable</code> 加上一个产生 <code>Observation</code> 的方法。我们大可以参考 <code>Observation</code> 的实现方式，将所有对它们的订阅行为储存起来。它们在这个阶段大体相同，所以我给了他们一个爸爸 <code>Notifier&lt;V&gt;</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notifier</span>&lt;<span class="title">V</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ObserverBlock</span> = (<span class="type">Observation</span>&lt;<span class="type">V</span>&gt;.<span class="type">Event</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Observer</span> = (<span class="type">String</span>, <span class="type">ObserverBlock</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> observers = [<span class="type">Observer</span>]()</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> latestEvent: <span class="type">Observation</span>&lt;<span class="type">V</span>&gt;.<span class="type">Event</span>? = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(<span class="number">_</span> event: Observation&lt;V&gt;.Event)</span></span> &#123;</span><br><span class="line">        latestEvent = event</span><br><span class="line">        observers.forEach &#123; $<span class="number">0.1</span>(event) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> block: @escaping ObserverBlock)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> uuid = <span class="type">UUID</span>().uuidString</span><br><span class="line">        observers.append((uuid, block))</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>, uuid] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">self</span>.observers.removeAll(<span class="keyword">where</span>: &#123; $<span class="number">0.0</span> == uuid &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">()</span></span> -&gt; <span class="type">Observation</span>&lt;<span class="type">V</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.main</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> e = <span class="keyword">self</span>.latestEvent &#123; </span><br><span class="line">                    queue.safeAsync &#123; observation.action(e) &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.addObserver &#123; event <span class="keyword">in</span></span><br><span class="line">                    queue.safeAsync &#123; observation.action(event) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要两个儿子在合适的时候调用 <code>notify</code> 方法就行了。至此我们的掷骰子程序就能用了！</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>但我们又怎么能就此满足，如果去看一些响应式的代码，会发现有很多将一个 <code>Observation</code> 转换为另一个 <code>Observation</code> 的代码……好吧，那我们也要有。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">viewModel.num.observe()</span><br><span class="line">    .ignoreLatest()</span><br><span class="line">    .<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"!!!"</span> &#125;</span><br><span class="line">    .bind(to: textField, at: \.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>幸亏目前的实现让我们能够很简单地实现这个功能，我们只需要在原有的 <code>Observation</code> 上创建新的 <code>Observation</code> 就可以了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;M&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(V)</span></span></span> -&gt; <span class="type">M</span>) -&gt; <span class="type">Observation</span>&lt;<span class="type">M</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observation</span>&lt;<span class="type">M</span>&gt; &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.subscribeEvent &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .next(v): observation.action(.next(transform(v)))</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .failure(e): observation.action(.failure(e))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而更多类型的操作符都能通过同样的方式实现，就不再累述了。</p><h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>不知道有没有人和我一样不喜欢 <code>UIControl.addTarget</code>。要让 <code>UIControl</code> 支持上述的响应式，需要首先给它一个 <code>subscribe</code> 方法让它返回一个 <code>Disposable</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetAction</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> block: () -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(action: @escaping () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.block = action</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">performAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(<span class="number">_</span> event: UIControl.Event, block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> targetAction = <span class="type">TargetAction</span>(action: block)</span><br><span class="line">    addTarget(targetAction, action: #selector(<span class="type">TargetAction</span>.performAction), <span class="keyword">for</span>: event)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposable</span> &#123; <span class="number">_</span> = targetAction &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要一个叫做 <code>TargetAction</code> 的类充当中间人，它将会把我们传入的 block 存起来，并在一个标记为 <code>@objc</code> 的方法中调用，这样一来在这个方法当中我们就不需要像以前那样把真正的 subscriber 传进来了。有了这个方法之后，我们就能够创建 <code>observe</code> 方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">(<span class="number">_</span> event: UIControl.Event)</span></span> -&gt; <span class="type">Observation</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(event) &#123; observation.action(.next(())) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些 <code>UIControl</code> 的变量并不支持 KVO，比如说 <code>UITextField.text</code>，我们会需要监听它的 <code>.editingChanged</code> 来感知这个值的变化，为了方便使用，我们可以再增加一个方法返回某个 keyPath 的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">textField.observe(.editingChanged, take: \.text)</span><br><span class="line">    .subscribe &#123; viewModel.search($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>爽。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后我们只需要在 Podfile 里加入 RxSwift，然后把上面写的代码删掉，就能愉快地 Reactive Programming 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一开始我其实只是想用 KVO 让 View Model 更响应式一些，可是 KVO 只支持 NSObject，用起来绑手绑脚，感觉没法进行下去。以前看过一些响应式的代码，想要模仿一下它们的风格。感觉要是有这么两个类型就好了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;，它内部持有一个变量，当这个变量发生改变时，通知其观察者。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Emitter&amp;lt;T&amp;gt;&lt;/code&gt;，当 ViewModel 发生了什么需要告知 ViewController 时，可以通过 &lt;code&gt;Emitter&lt;/code&gt; 发送一个事件，通知其所有的观察者。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;譬如说我们要写一个掷骰子的程序，这个程序最奇特的一处是当我们多次掷到的数字之和超过 36，就会弹出一个弹窗告诉我们掷到了 36。我们的 ViewModel 可以这样子写：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewModel&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num = &lt;span class=&quot;type&quot;&gt;Observable&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; thirtySix = &lt;span class=&quot;type&quot;&gt;Emitter&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Void&lt;/span&gt;&amp;gt;(())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;roll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; newNum = &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;.random(&lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;...&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num.val = newNum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sum += newNum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; sum &amp;gt;= &lt;span class=&quot;number&quot;&gt;36&lt;/span&gt; &amp;#123; thirtySix.emit(()) &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://intii.com/tags/Xcode/"/>
    
      <category term="KVO" scheme="http://intii.com/tags/KVO/"/>
    
      <category term="RxSwift" scheme="http://intii.com/tags/RxSwift/"/>
    
      <category term="Reactive Programming" scheme="http://intii.com/tags/Reactive-Programming/"/>
    
      <category term="Live Data" scheme="http://intii.com/tags/Live-Data/"/>
    
      <category term="Observable" scheme="http://intii.com/tags/Observable/"/>
    
  </entry>
  
  <entry>
    <title>NonScrollView，一种嵌套 UIScrollView 的方法</title>
    <link href="http://intii.com/2019/create-complicated-nested-scrollviews-with-nonscrollview/"/>
    <id>http://intii.com/2019/create-complicated-nested-scrollviews-with-nonscrollview/</id>
    <published>2019-01-15T03:30:00.000Z</published>
    <updated>2019-01-15T16:15:53.492Z</updated>
    
    <content type="html"><![CDATA[<p>公司的项目有一个页面需要在 Segment Control 上面加一个 header，</p><p>原本的是现实监听 segment controller 下每一个列表的 <code>contentOffset</code> 以调整 header 的位置，尽管能用，但毕竟它的最外层不是一个 <code>UIScrollView</code> 了，接手之后突然让我给整体加个加拉刷新，着实是让我很烦心。当时时间比较赶，我就直接加了个 <code>UIPanGestureRecognizer</code>，效果还是很糟糕的。最近比较闲，于是想着重构一下这个部分，我当然希望最外层是一个 <code>UIScrollView</code>，但这就涉及到了两个嵌套 scroll view 的问题了：</p><ol><li>什么时候拖动哪一个 scroll view；</li><li>当一个 scroll view over scroll 的时候，怎么反映到另外一个 scroll view 上；</li></ol><p>Google 了一番，看到的一些想法是监听 scroll view 的 <code>contentOffset</code> 并判断拖动的是哪一个 scroll view。这个方法可以解决第一个问题，但是却不能解决第二个问题。当然我们也可以实现一个 pan gesture 完全接管嵌套 scroll view 的滑动，但这样就失去了 <code>UIScrollView</code> 自带的 over scroll 效果了。</p><p>后来我想到了 <code>UICollectionView</code>。用正常的 flow layout 时也许不太明显，但当我们在做一些奇怪的布局的时候，不就是将 <code>contentOffset</code> 转化成了各个 cell 的 <code>frame</code> 吗？我们是不是可以把 <code>contentOffset</code> 看作是<ruby>进度<rt>progress</rt></ruby>，从而计算出当前进度下各个部分的 <code>frame</code> 呢？</p><p>当然我们才不要用 <code>UICollectionView</code>，没有理由又做一个 cell 把 view controller 填到里面去。</p><a id="more"></a><h2 id="Content-Offset-看作进度"><a href="#Content-Offset-看作进度" class="headerlink" title="Content Offset 看作进度"></a>Content Offset 看作进度</h2><p>我们首先看一个例子：<strong>我们希望把两个 <code>UITableView</code> 在竖直方向上串联起来，它们在滚动时，看起来就像是一个 <code>UITableView</code> 一样。</strong></p><div style="display:inline-block"><div style="float:left;width:300px;margin-left:-3em;margin-right:3em;display:inline-block"><video src="https://raw.githubusercontent.com/intitni/int123c.github.io/master/media/create-complicated-viewcontrollers-with-nonscrollview/scroll-view-chain.MP4" alt="scroll view chain" style="width:100%;" autoplay="autoplay" controls="controls"></video><br></div><p>能够想象出来的一种布局方案就是：</p><ol><li>最外层是一个 scroll view，姑且叫做 M；</li><li>scroll view 中竖直放置两个连续的 table view，A 和 B，两个 table view 的宽高皆与最外层的 M 相等；</li><li>当 A 的 content size 足够长时，我们让 M 下滚时，首先让 A 下滚；</li><li>A 下滚到尽头之后，变为同时上移 A 和 B；</li><li>当 B 上移到 M 顶部之后，变为让 B 下滚。</li></ol><p>幸运的是 A、B 的 <code>frame</code> 和 <code>contentOffset</code> 都能映射到 M 的 <code>contentOffset</code> 上。也就是说我们只需要给 scroll view 增加一个功能，让它在 <code>layoutSubviews</code> 的过程中根据 <code>contentOffset</code> 设置 A 和 B 的 <code>frame</code> 和 <code>contentOffset</code> 就行了。</p><p>在这个例子里 A 的 <code>contentOffset</code> 实际上就是 M 的 <code>contentOffset</code>；而 B 的 <code>contentOffset</code> 只需将 M 的 <code>contentOffset</code> 减去 A 的 <code>contentSize.height</code> 即可得到。实际实现中会需要考虑到一些别的情况，这里便不再累赘了。<br></div><br>我们姑且称这个新的 scroll view 为 <code>NonScrollView</code>。<code>NonScrollView</code> 会在 <code>layoutSubviews</code> 末尾执行上述的逻辑。我们希望 scroll view 的滚动完全由 <code>NonScrollView</code> 接管，因此需要先将 scroll view 设为不可滚动。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutMappedViews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> placer <span class="keyword">in</span> layout.viewPlacers &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> frameInVisible = placer.generateViewFrame(frameOfReference)</span><br><span class="line">        <span class="keyword">let</span> frame = <span class="type">CGRect</span>(origin: frameInVisible.origin + contentOffset,</span><br><span class="line">                           size: frameInVisible.size)</span><br><span class="line">        placer.view.frame = frame</span><br><span class="line">        placer.updateView?(frameOfReference)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要为 <code>NonScrollView</code> 提供一些 <code>ViewPlacer</code>，它们包含了需要更新的 view 以及两个 block 用来生成对应状态下的 <code>frame</code> 和更新 view 的状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewPlacer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> view: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">let</span> generateViewFrame: (<span class="type">FrameOfReference</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line">    <span class="keyword">let</span> updateView: ( (<span class="type">FrameOfReference</span>) -&gt; <span class="type">Void</span> )?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NonScrollView</code> 的 <code>contentSize</code> 也需要我们提供一个逻辑来生成，在这个例子当中，它应该就是 <code>A.contentSize + B.contentSize</code>（竖直方向上）。为了能够在 A、B 高度发生变化时动态地更新 M 的高度，我们可以通过 KVO 进行监听，并适时更新 <code>M.contentSize</code>。</p><p>至此我们已经可以实现图中的效果了。</p><h2 id="Content-Offset-看作手势"><a href="#Content-Offset-看作手势" class="headerlink" title="Content Offset 看作手势"></a>Content Offset 看作手势</h2><div style="display:inline-block"><div style="float:left;width:300px;margin-left:-3em;margin-right:3em;display:inline-block"><video src="https://raw.githubusercontent.com/intitni/int123c.github.io/master/media/create-complicated-viewcontrollers-with-nonscrollview/segment-controller.MP4" alt="scroll view chain" style="width:100%;" autoplay="autoplay" controls="controls"></video><br></div><p>但当回到我们最初的需求，这个方法就不可行了。</p><p>在最初的需求当中，我们可以切换到不同的页面，但不同页面的 <code>contentOffset</code> 可能并不一样，这就导致了进度，<code>M.contentOffset</code>，不一样。如果进度不一样，按照上一个例子的做法，segment control 的位置也会发生改变。也就与我们的需求发生了冲突。我的天啊。</p><p>正当我要绝望的时候，我想到既然我们可以用一个手势完全接管滑动，为什么我们不能把 <code>contentOffset</code> 的变化就看作是一种手势呢？<code>contentOffset</code> 自身的值就是 <code>location(in:)</code>，我们还可以记录一个 <code>lastContentOffset</code>，两者作差，就得到了 <code>translation(in:)</code>，再加上一些 state 属性，俨然一个 gesture recognizer。<br></div><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonScrollViewScrollRecognizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> onChange: ((<span class="type">NonScrollViewScrollRecognizer</span>)-&gt;<span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> scrollState: <span class="type">ScrollState</span> &#123; <span class="keyword">return</span> ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> touchState: <span class="type">UIGestureRecognizer</span>.<span class="type">State</span> &#123; <span class="keyword">return</span> ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> lastContentOffset: <span class="type">CGPoint</span> = .zero</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> contentOffset: <span class="type">CGPoint</span> = .zero</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> translation: <span class="type">CGPoint</span> &#123; <span class="keyword">return</span> contentOffset - lastContentOffset &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">touchLocation</span><span class="params">(<span class="keyword">in</span> view: UIView?)</span></span> -&gt; <span class="type">CGPoint</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> panGestureRecognizer.location(<span class="keyword">in</span>:view)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不如来试一试吧。</p><p>我们依旧创建一个 <code>NonScrollView</code>，但在 <code>generateFrame</code> 中我们返回的东西就简单多了，毕竟这次我们不再需要将 <code>contentOffset</code> 映射成 <code>frame</code>，而是根据 <code>contentOffset</code> 的变化不断改变 <code>frame</code> 以及当前显示的 scroll view 的 <code>contentOffset</code>。</p><p>我们可以用一个属性 <code>segmentControllerOrigin</code> 用来记录 segment controller 在屏幕上的位置，并以此计算出 <code>headerVC</code> 的位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">viewPlacers: [</span><br><span class="line">    .<span class="keyword">init</span>(view: headerVC.view, generateFrame: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] ref <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> .zero </span><br><span class="line">             + <span class="type">CGSize</span>(width: ref.size.width, height:<span class="keyword">self</span>.segmentControllerOrigin.y)</span><br><span class="line">    &#125;),</span><br><span class="line">    .<span class="keyword">init</span>(view: segmentController.view, generateFrame: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] ref <span class="keyword">in</span></span><br><span class="line">         <span class="keyword">return</span> .<span class="keyword">init</span>(origin: <span class="keyword">self</span>.segmentControllerOrigin, size: ref.size)</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来就跟我们使用 <code>UIPanGestureRecognizer</code> 的时候差不多了。我们可以通过 <code>onChange</code> 属性监听 <code>NonScrollViewScrollRecognizer</code> 的变化。比方说列表在往上滚，且 segment controller 还未至顶的时候，我们就可以将竖直方向的位移加给 <code>segmentControllerOrigin</code>，而在至顶之后加给当前页面的 <code>contentOffset</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">self</span>.currentScrollView, hitTop, scrollDirection) &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> scrollable?, <span class="literal">true</span>, .scrollUp):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> scrollable.contentOffset.y &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newOffset = scrollable.contentOffset + rec.translation</span><br><span class="line">        scrollable.contentOffset = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="built_in">max</span>(newOffset.y, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> newOffset.y &lt; <span class="number">0</span> &#123; <span class="comment">// over scroll</span></span><br><span class="line">            <span class="keyword">self</span>.segmentControllerOrigin -= <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: newOffset.y)</span><br><span class="line">            <span class="keyword">self</span>.calibrateContentOffset()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newOrigin = <span class="keyword">self</span>.segmentControllerOrigin - rec.translation</span><br><span class="line">        <span class="keyword">self</span>.segmentControllerOrigin = .<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="built_in">max</span>(newOrigin.y, <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> scrollable?, <span class="literal">false</span>, .scrollUp):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> scrollable.contentOffset.y &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.touchBeginsInSegmentController &#123;</span><br><span class="line">            <span class="keyword">let</span> newOffset = scrollable.contentOffset + rec.translation</span><br><span class="line">            scrollable.contentOffset = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="built_in">max</span>(newOffset.y, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> newOffset.y &lt; <span class="number">0</span> &#123; <span class="comment">// over scroll</span></span><br><span class="line">                <span class="keyword">self</span>.segmentControllerOrigin -= <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: newOffset.y)</span><br><span class="line">                <span class="keyword">self</span>.calibrateContentOffset()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newOrigin = <span class="keyword">self</span>.segmentControllerOrigin - rec.translation</span><br><span class="line">            <span class="keyword">self</span>.segmentControllerOrigin = .<span class="keyword">init</span>(x: <span class="number">0</span>, y: newOrigin.y)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newOrigin = <span class="keyword">self</span>.segmentControllerOrigin - rec.translation</span><br><span class="line">        <span class="keyword">self</span>.segmentControllerOrigin = .<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="built_in">max</span>(newOrigin.y, <span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步外层的 <code>contentOffset</code> 和内层的 <code>contentOffset</code> 以及 <code>segmentControllerOrigin</code> 是比较恶心的一处。反正我就是搞不对，就写了很多 <code>calibrateContentOffset()</code>。</p><p><a href="https://github.com/int123c/NonScrollView">Demo 在这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的项目有一个页面需要在 Segment Control 上面加一个 header，&lt;/p&gt;
&lt;p&gt;原本的是现实监听 segment controller 下每一个列表的 &lt;code&gt;contentOffset&lt;/code&gt; 以调整 header 的位置，尽管能用，但毕竟它的最外层不是一个 &lt;code&gt;UIScrollView&lt;/code&gt; 了，接手之后突然让我给整体加个加拉刷新，着实是让我很烦心。当时时间比较赶，我就直接加了个 &lt;code&gt;UIPanGestureRecognizer&lt;/code&gt;，效果还是很糟糕的。最近比较闲，于是想着重构一下这个部分，我当然希望最外层是一个 &lt;code&gt;UIScrollView&lt;/code&gt;，但这就涉及到了两个嵌套 scroll view 的问题了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么时候拖动哪一个 scroll view；&lt;/li&gt;
&lt;li&gt;当一个 scroll view over scroll 的时候，怎么反映到另外一个 scroll view 上；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Google 了一番，看到的一些想法是监听 scroll view 的 &lt;code&gt;contentOffset&lt;/code&gt; 并判断拖动的是哪一个 scroll view。这个方法可以解决第一个问题，但是却不能解决第二个问题。当然我们也可以实现一个 pan gesture 完全接管嵌套 scroll view 的滑动，但这样就失去了 &lt;code&gt;UIScrollView&lt;/code&gt; 自带的 over scroll 效果了。&lt;/p&gt;
&lt;p&gt;后来我想到了 &lt;code&gt;UICollectionView&lt;/code&gt;。用正常的 flow layout 时也许不太明显，但当我们在做一些奇怪的布局的时候，不就是将 &lt;code&gt;contentOffset&lt;/code&gt; 转化成了各个 cell 的 &lt;code&gt;frame&lt;/code&gt; 吗？我们是不是可以把 &lt;code&gt;contentOffset&lt;/code&gt; 看作是&lt;ruby&gt;进度&lt;rt&gt;progress&lt;/rt&gt;&lt;/ruby&gt;，从而计算出当前进度下各个部分的 &lt;code&gt;frame&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;当然我们才不要用 &lt;code&gt;UICollectionView&lt;/code&gt;，没有理由又做一个 cell 把 view controller 填到里面去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="NonScrollView" scheme="http://intii.com/tags/NonScrollView/"/>
    
      <category term="UIScrollView" scheme="http://intii.com/tags/UIScrollView/"/>
    
      <category term="嵌套" scheme="http://intii.com/tags/%E5%B5%8C%E5%A5%97/"/>
    
      <category term="UIViewController" scheme="http://intii.com/tags/UIViewController/"/>
    
      <category term="Container" scheme="http://intii.com/tags/Container/"/>
    
      <category term="ContainerViewController" scheme="http://intii.com/tags/ContainerViewController/"/>
    
      <category term="Xcode" scheme="http://intii.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Optional Tuple 和 Function</title>
    <link href="http://intii.com/2018/flatmapping-optional-tuple-with-function/"/>
    <id>http://intii.com/2018/flatmapping-optional-tuple-with-function/</id>
    <published>2018-11-25T01:21:00.000Z</published>
    <updated>2018-11-25T14:37:26.485Z</updated>
    
    <content type="html"><![CDATA[<p>见到 optional 的东西时我都会有种莫名的舒爽，因为我可以用 <code>map</code> 或者 <code>flatMap</code> 将它作为参数传给某个函数，并将结果又以同样的方式传递给下一个函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newImage = imageThatIsOptional</span><br><span class="line">    .<span class="built_in">map</span>(scale)</span><br><span class="line">    .<span class="built_in">map</span>(rotate)</span><br></pre></td></tr></table></figure><p>但偶尔我们会碰到一些拥有多个参数的函数，比如说 <code>crop(_ image: UIImage, with rect: CGRect)</code>，这时链式调用就尴尬了。</p><a id="more"></a><p>曾几何时，我们是可以把 tuple 直接作为多参数函数的参数的，那个时候我们可以写成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple = (image, .zero)</span><br><span class="line">crop(tuple) <span class="comment">// now it would be error: missing argument for parameter 'with' in call</span></span><br></pre></td></tr></table></figure><p>后来 Swift 取消了这个功能，我们不能再直接将 tuple 作为参数了。但是，我们依然能够通过 <code>map</code> 的方式，将一个 optional 的 tuple 作为参数传给函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: (<span class="type">UIImage</span>, <span class="type">CGRect</span>)? = (image, <span class="type">CGRect</span>.zero)</span><br><span class="line">tuple.<span class="built_in">map</span>(crop)</span><br></pre></td></tr></table></figure><p>很棒吧，但我们还需要解决一个问题，那就是怎么优雅地创建这个 tuple。<a href="https://twitter.com/johnsundell/status/1066012565615071233">John Sundell 给我们推荐了一个方法</a>——再给 <code>Optional</code> 加个 <code>flatMap</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(with expression: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">T</span>?) -&gt; (<span class="type">Wrapped</span>, <span class="type">T</span>)? &#123;</span><br><span class="line">        <span class="keyword">return</span> flatMap &#123; a <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> expression().<span class="built_in">map</span> &#123; b <span class="keyword">in</span> <span class="keyword">return</span> (a, b) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newImage1 = image.<span class="built_in">map</span>(scale).flatMap(with: <span class="type">CGRect</span>.zero).<span class="built_in">map</span>(crop)</span><br><span class="line"><span class="comment">// 当值不是 optional 的时候，我们也可以强行让它变成 optional</span></span><br><span class="line"><span class="keyword">let</span> newImage2 = <span class="type">Optional</span>(<span class="type">UIImage</span>()).flatMap(with: <span class="type">CGRect</span>.zero).<span class="built_in">map</span>(crop)</span><br></pre></td></tr></table></figure><p>当然我们也可以从方法下手，用 <a href="https://github.com/pointfreeco/swift-overture">swift-overture</a> 这种东西把 <code>crop</code> 变成只需要一个参数的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;见到 optional 的东西时我都会有种莫名的舒爽，因为我可以用 &lt;code&gt;map&lt;/code&gt; 或者 &lt;code&gt;flatMap&lt;/code&gt; 将它作为参数传给某个函数，并将结果又以同样的方式传递给下一个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; newImage = imageThatIsOptional&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(scale)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(rotate)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但偶尔我们会碰到一些拥有多个参数的函数，比如说 &lt;code&gt;crop(_ image: UIImage, with rect: CGRect)&lt;/code&gt;，这时链式调用就尴尬了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Optional" scheme="http://intii.com/tags/Optional/"/>
    
      <category term="Tuple" scheme="http://intii.com/tags/Tuple/"/>
    
      <category term="flatMap" scheme="http://intii.com/tags/flatMap/"/>
    
      <category term="Monad" scheme="http://intii.com/tags/Monad/"/>
    
      <category term="Function" scheme="http://intii.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>新头像，史莱姆</title>
    <link href="http://intii.com/2018/new-avatar-slime-not-evil/"/>
    <id>http://intii.com/2018/new-avatar-slime-not-evil/</id>
    <published>2018-11-07T11:21:31.000Z</published>
    <updated>2018-11-25T14:34:08.967Z</updated>
    
    <content type="html"><![CDATA[<p>本季最喜欢的动画大概就是转生变成史莱姆了吧，实在是太可爱了，看了第一集就决定新头像是史莱姆了，但拖延了一个月才画（<br><a id="more"></a><br><img src="/media/slime-not-evil.PNG" alt="slime-not-evil"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本季最喜欢的动画大概就是转生变成史莱姆了吧，实在是太可爱了，看了第一集就决定新头像是史莱姆了，但拖延了一个月才画（&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写一个 Mock API Server 让生活更简单</title>
    <link href="http://intii.com/2018/make-life-easier-with-mock-api-server/"/>
    <id>http://intii.com/2018/make-life-easier-with-mock-api-server/</id>
    <published>2018-08-18T03:21:00.000Z</published>
    <updated>2018-11-12T05:24:05.540Z</updated>
    
    <content type="html"><![CDATA[<p>公司项目的业务逻辑蛮复杂的，有时候我们需要测试 UI，就得让订单达到某一个特定的状态，往往需要在后台里先点个几分钟。其实最后我们还不是拿的后端返回的数据来填充 UI，所以为什么不直接把这个状态的数据构造好，直接拿来使用呢？所以我还是决定写个 Mock Server。</p><p>Mock Server 的功能很简单：</p><ol><li>根据 API Endpoint，返回配置文件中指定的 JSON 文件；</li><li>可以局部匹配参数，返回指定的 JSON 文件。</li></ol><p>后来 Android 端的小伙伴似乎也有点兴趣，但不想总是改代码指向 Mock Server，那行，我们就再加一个功能：<strong>3. 配置文件中没有指定的接口的请求，转发到开发服务器中。</strong></p><a id="more"></a><p>前两部分很简单，就是写一个 API Server 而已。因为懒得碰其它语言，直接使用了 Swift + Vapor。每次收到请求，我们都读取一下配置文件，大概是这么个结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pref</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> endpoints: [<span class="type">Endpoint</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Endpoint</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> endpoint: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> filename: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dispatch: [<span class="type">Dispatcher</span>]?</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dispatcher</span>: <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> parameters: <span class="type">JSONValue</span></span><br><span class="line">        <span class="keyword">let</span> filename: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">match</span><span class="params">(<span class="number">_</span> param: JSONValue)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parameters.compare(param)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得请求后，我们首先判断接口是否在 <code>Pref.endpoints</code> 中，如果有，则在看其参数是否存在一个子集处于 <code>Endpoint.dispatch</code> 中，如果有则使用其中的 <code>filename</code>.json，没有则 Fallback 到 <code>Endpoint.filename</code>.json。</p><p>对于其它的一切情况，返回 404。</p><p>第三点就比较麻烦了，一开始我想在 Mock Server 里再发一次请求，尽管咨询了后端的同学，但最终还是遇到了一些我暂时解决不了的问题：</p><ol><li>多个请求同时来的时候会收不到一些响应；</li><li>用 Nginx 实现 HTTPS 的时候，响应会变成双倍。但 Vapor 3 直接实现 HTTPS，找遍了 Google 都没找到方法。</li></ol><p>我倒腾了很久都没搞懂是什么情况……最后 Google 发现 Nginx 有一个东西叫做 <code>proxy_next_upstream</code>，我们可以指定多个 Upstream，如果一个有问题，就用下一个。所以我们可以写下这样的 Upstream：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> w &#123;</span><br><span class="line">    <span class="attribute">server</span> localhost:4343 max_fails=0 weight=200;</span><br><span class="line">    <span class="attribute">server</span> real.dev.api.server.com:443 max_fails=0 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是要写下权重，避免 Nginx 轮询调用。</p><p>然后再写两个 Server：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server</span> &#123; #A</span><br><span class="line">    <span class="attribute"><span class="nomarkup">listen</span></span>       80;</span><br><span class="line">    <span class="attribute"><span class="nomarkup">listen</span></span>       443 ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  real.dev.api.server.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> servernew.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span>    shared:SSL:1m;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  5m;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> https://w;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host real.dev.api.server.com;</span><br><span class="line">        <span class="attribute">proxy_next_upstream</span> error timeout http_500 http_502 http_503 http_504 http_404 invalid_header non_idempotent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> &#123; #B</span><br><span class="line">    <span class="attribute"><span class="nomarkup">listen</span></span>       4343 ssl;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> servernew.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:9090;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host real.dev.api.server.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，通过改 Host 或改代码指向本机 IP 的方式，我们就能通过 Server#A 先调用 Mock Server，如果配置文件中没有请求的接口，则返回 404，接着调用真实的开发环境接口。</p><p>Server#B 是因为 Server#A 的 <code>proxy_pass</code> 用的是 <code>https</code>，试了一下有问题，所以又做了一层。我并不清楚以上哪一行是多余的，反正能用（</p><p>现在我们就能无痛使用 Mock Server 获得假数据了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司项目的业务逻辑蛮复杂的，有时候我们需要测试 UI，就得让订单达到某一个特定的状态，往往需要在后台里先点个几分钟。其实最后我们还不是拿的后端返回的数据来填充 UI，所以为什么不直接把这个状态的数据构造好，直接拿来使用呢？所以我还是决定写个 Mock Server。&lt;/p&gt;
&lt;p&gt;Mock Server 的功能很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据 API Endpoint，返回配置文件中指定的 JSON 文件；&lt;/li&gt;
&lt;li&gt;可以局部匹配参数，返回指定的 JSON 文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后来 Android 端的小伙伴似乎也有点兴趣，但不想总是改代码指向 Mock Server，那行，我们就再加一个功能：&lt;strong&gt;3. 配置文件中没有指定的接口的请求，转发到开发服务器中。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Vapor" scheme="http://intii.com/tags/Vapor/"/>
    
      <category term="Nginx" scheme="http://intii.com/tags/Nginx/"/>
    
      <category term="API Server" scheme="http://intii.com/tags/API-Server/"/>
    
  </entry>
  
  <entry>
    <title>通过 Sourcery 来写 API Client</title>
    <link href="http://intii.com/2018/write-api-client-with-sourcery/"/>
    <id>http://intii.com/2018/write-api-client-with-sourcery/</id>
    <published>2018-06-25T03:21:00.000Z</published>
    <updated>2018-11-29T14:46:55.522Z</updated>
    
    <content type="html"><![CDATA[<p>我不太喜欢现在公司项目中 API Client 的实现方式，虽然并没有什么问题，但我还是忍不住要重构一下。原本的实现是这样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeModel</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)doSomething:(<span class="built_in">NSString</span> *)aParam completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> isSuccess, <span class="built_in">NSString</span> *errorMessage, SomeModel * someModel))completion &#123;</span><br><span class="line">    [APIClient.sharedClient </span><br><span class="line">        POST:someEndpoint</span><br><span class="line">        parameters: @&#123; <span class="string">@"p"</span>: aParam &#125;</span><br><span class="line">        success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">            PPApiResponseObject *responseItem = [PPApiResponseObject createFrom:responseObject];</span><br><span class="line">            <span class="keyword">if</span> (responseItem.isSuccess) &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里有几个地方是我不喜欢的：1. 用 Objective C 写的；2. API 不太现代；3. endpoint 分散在了不同的 model 定义里面；4. 重复的东西太多。</p><a id="more"></a><h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>这次重构我不想有太大的改动，所以 <code>[APIClient.sharedClient...]</code> 那部分我是会保留的，同时我也需要支持 Objective C，于是用 enum 来表示 endpoint 这种事情肯定是做不到的了。为了能好好利用自动补全，我还是会采用方法来实现每一个 endpoint，只是这次我们会把它们都放在一个类里，就叫作 <code>API</code> 吧。</p><p>事实上这些方法的实现都大同小异，这种情况就特别适合使用元编程了，我希望我能够以 declarative 的方式定义一个 endpoint，然后再通过 Sourcery 来自动生成代码。我希望这个定义是这个样子的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ProductSearch</span>: <span class="title">APIEndPoint</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> endpoint = <span class="string">"/app/search"</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RequestBody</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> keyword: <span class="type">String</span></span><br><span class="line">            <span class="keyword">let</span> page: <span class="type">Int</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ResponseBody</span>: <span class="title">ResponseBodyType</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> totalCount: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">let</span> products: [<span class="type">Product</span>]; <span class="class"><span class="keyword">struct</span> <span class="title">Product</span>: <span class="title">ResponseBodyType</span> </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> productId: <span class="type">Int</span></span><br><span class="line">                <span class="keyword">let</span> productName: <span class="type">String</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就和我们的 API 文档一模一样，<code>APIEndPoint</code> 是一个 protocol，一方面可以指导我定义一个 endpoint，另一方面，可以告诉 Sourcery 我们都有哪一些 endpoint 需要生成代码。实现 <code>ResponseBodyType</code> 的类型需要同时实现 <code>Codable</code>，这样我们就能将 JSON 转化为 Model 了。这同时也能够告诉 Sourcery，有哪一些类型我们需要提供一个 Objective C 可以理解的版本，毕竟无论是嵌套类型还是 struct，Objective C 都是不认的。</p><p>我决定用一个 class 把它包住。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API_ProductSearch_ResponseBody</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body: <span class="type">API</span>.<span class="type">ProductSearch</span>.<span class="type">ResponseBody</span></span><br><span class="line">    <span class="keyword">init</span>(body: <span class="type">API</span>.<span class="type">ProductSearch</span>.<span class="type">ResponseBody</span>) &#123; <span class="keyword">self</span>.body = body &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> totalCount: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> body.totalCount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">var</span> product: [<span class="type">API_ProductSearch_ResponseBody_Product</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> body.product.<span class="built_in">map</span>(<span class="type">API_ProductSearch_ResponseBody_Product</span>.<span class="keyword">init</span>(body:))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现部分，我希望和原本差不多，但 completion handler 的参数是一个 <code>enum Result&lt;Body&gt;</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">productSearch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keyword: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    page: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> completion: @escaping <span class="params">(Result&lt;API.ProductSearch.ResponseBody&gt;)</span></span></span>-&gt;<span class="type">Void</span> = &#123;<span class="number">_</span> <span class="keyword">in</span>&#125;) -&gt; <span class="type">URLSessionDataTask</span>? &#123;</span><br><span class="line">    <span class="comment">// prepare parameter dictionary</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">APIClient</span>.sharedClient().post(<span class="type">API</span>.<span class="type">ProductSearch</span>.endpoint, </span><br><span class="line">            parameters: param,</span><br><span class="line">            success:&#123; task, responseObject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;, failure:&#123; task, error <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然还需要一个 Objective C 的版本，自然也就不能用 <code>Result</code> 了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">post_productSearch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keyword: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    page: Int,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> completion: @escaping <span class="params">(API_ProductSearch_ResponseBody?, NSError?)</span></span></span>-&gt;<span class="type">Void</span> = &#123;<span class="number">_</span>, <span class="number">_</span> <span class="keyword">in</span>&#125;) -&gt; <span class="type">URLSessionDataTask</span>?</span><br></pre></td></tr></table></figure><p>既然大致的方向决定了，接下来就是写模板了。</p><h2 id="写模板"><a href="#写模板" class="headerlink" title="写模板"></a>写模板</h2><p><span style="color: #680000">❖ 因为 Hexo 会尝试去解析 stencil 模板，所以文章中用 {٪ 来防止解析发生。</span></p><h3 id="适配-Objective-C"><a href="#适配-Objective-C" class="headerlink" title="适配 Objective C"></a>适配 Objective C</h3><p>写这个部分的模板还是比较烦人的，因为 Objective C 并不支持 Swift 里面的所有类型。</p><p>首先是提供 Objective C 可以理解的 response body。就像之前所说的那样，我们只需要让一个 class 把每一个实现 <code>ResponseBodyType</code> 的类型包起来就行了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;٪<span class="keyword">for</span> responseBody <span class="keyword">in</span> types.all <span class="keyword">where</span> responseBody.implements.<span class="type">ResponseBodyType</span>%&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> </span>&#123;&#123;responseBody.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125;: <span class="type">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> body: &#123;&#123;responseBody.name&#125;&#125;</span><br><span class="line">    <span class="keyword">init</span>(body: &#123;&#123;responseBody.name&#125;&#125;) &#123; <span class="keyword">self</span>.body = body &#125;</span><br><span class="line">    &#123;٪<span class="keyword">for</span> variable <span class="keyword">in</span> responseBody.variables%&#125;</span><br><span class="line">    <span class="comment">// variables</span></span><br><span class="line">    &#123;٪endfor%&#125;</span><br><span class="line">&#123;٪endfor%&#125;</span><br></pre></td></tr></table></figure><p>Stencil 提供了一些内置的 filter，所以我们能够很简单地将一些嵌套类型的名称 <code>A.B.C</code> 转变成 <code>A_B_C</code>。Variable 部分需要比较注意的是，像 <code>Int?</code> 这种东西  Objective C 也是看不懂的，需要额外处理成 <code>NSNumber</code>，当 variable 是 <code>ResponseBodyType</code> 或 <code>[ResponseBodyType]</code> 或 <code>ResponseBodyType?</code> 之类的也需要额外处理，挺啰嗦的，这里就不一一写明了。Sourcery 中 <code>Variable</code> 有两个参数 <code>type</code> 和 <code>typeName</code>，说实话很诡异，必须得好好看文档才知道什么时候该用什么。</p><p>对 <code>ResponseBodyType?</code> 这种情况目前还没有很好的解决方法， <code>typeName.unwrappedTypeName</code> 返回的是 <code>String</code> 而不是 <code>TypeName</code>，正巧我把这些类型都嵌套在 <code>API</code> 里，可以判断其 <code>actualTypeName</code> 的前缀来捕获这种情况。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;٪<span class="keyword">if</span> variable.typeName.isOptional and variable.typeName.actualTypeName|hasPrefix:<span class="string">"API."</span> %&#125;</span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> &#123;&#123;variable.name&#125;&#125;: &#123;&#123;variable.typeName.actualTypeName.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> v = body.&#123;&#123;variable.name&#125;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#123;variable.type.name|replace:<span class="string">"."</span>,<span class="string">"_"</span>&#125;&#125;(body: v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;٪endif%&#125;</span><br></pre></td></tr></table></figure><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>提供 Objective C 版本的请求方法很简单，就是内部调用 Swift 版本的方法。这部分需要注意的只有一些 optional 的参数类型可能要用别的类型替换，就一笔带过了。</p><p>有了上一个小节的经验，我们可以发现这些模板的写法都大同小异。对方法签名的参数生成和请求参数的生成，无非都是遍历 <code>RequestBody</code> 的 <code>variables</code> 而已。唯一值得一提的是，我们可以用 <code>{٪if var.variables.count == 0%}</code> 来判断一个数组是否为空，还可以通过 <code>{٪if forloop.last%}</code> 来判断是否是当前循环的最后一次。很多用法其实都没有写在 Sourcery 的文档里面，不妨也去看看 Stencil 的文档。</p><h3 id="Coding-Keys"><a href="#Coding-Keys" class="headerlink" title="Coding Keys"></a>Coding Keys</h3><p>有时候我们希望不用去刻意地让属性的名称和 JSON 里的 key 完全对应上，因为有的 key 的命名真的是难以理解，这时我们也可以利用 Sourcery 帮助我们自动生成相关的代码。</p><p><a href="https://intii.com/2017/codable-enum-with-associated-values/%60">和我之前的文章一样</a>，我们用 <code>AutoCodable</code> 来指定这些需要生成代码的类型，但幸运的是，我们没有必要和 Enum with Associated Value 做斗争了。</p><p>仔细观察了一下，我大概有这么几个需求：</p><ol><li>类型为数组时，默认值为 <code>[]</code></li><li>可以指定默认值 <code>defaultValue = 0</code></li><li>可以指定 key <code>jsonKey = &quot;abc&quot;</code></li><li>某一些情况将 <code>Int</code> 转为 <code>Bool</code></li></ol><p>对于数组默认值，我们只需要把对应情况的 <code>decode</code> 改成 <code>decodeIfPresent ?? []</code> 就好了。</p><p>后三者则用到了 Sourcery 中的 annotation 功能，通过注释给 Sourcery 传递代码以外的信息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sourcery: jsonKey = "id"</span></span><br><span class="line"><span class="comment">// sourcery: defaultValue = 0</span></span><br><span class="line"><span class="keyword">let</span> productId: <span class="type">Int</span></span><br><span class="line"><span class="comment">// sourcery: boolFromInt</span></span><br><span class="line"><span class="keyword">let</span> worthBuying: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>模板中可以通过 <code>annotated</code> 这个 filter 来判断目标是否有相应的注释。也可以通过 <code>something.annotation.jsonKey</code> 这种方式来获取注释的值。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>元编程的一个好处就是没有复杂的设计，这使得扩展变得很容易。比如说，我们可以给 endpoint 增加一个获取 mock response 的功能。我们通过判断 endpoint 是否实现某一个 protocol 来决定是否插入代码。</p><p>对于这个扩展，endpoint 需要实现 <code>APIEndPointHasFakeResponse</code> 这个 protocol：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">APIEndPointHasFakeResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">handleRequestWithMockResponse</span><span class="params">(<span class="number">_</span> param: [String: Any]?, completionHandler: <span class="params">(Result&lt;Data&gt;)</span></span></span>-&gt;<span class="type">Void</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，我们既可以直接返回一段 JSON，也可以将请求转发给 mock server 来获取一段 mock response。当然我们也可以只对特定的请求做处理，并在这种情况下返回 <code>false</code>。</p><p>我们完全不用担心这些多余的扩展会污染我们的代码，毕竟这些代码只有在实现了协议的情况下才会插入到请求方法当中；我们也可以在 extension 中实现这个协议，以保持 endpoint 定义的纯洁性，当我们不需要 mock response 了，只需要随手删掉相关代码就可以了。</p><p>我们也可以只移除 protocol 而保留方法的实现，以方便下一次使用。</p><p>我们可以把这一部分写成一个 macro：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;٪macro extensionFakeResponse type requestBody%&#125;</span><br><span class="line">&#123;٪<span class="keyword">if</span> type.implements.<span class="type">APIEndPointHasFakeResponse</span>%&#125;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">        <span class="keyword">if</span> &#123;&#123;type.name&#125;&#125;.handleRequestWithMockResponse(&#123;٪call paramOrNil requestBody-%&#125;, completionHandler: &#123; </span><br><span class="line">            <span class="keyword">switch</span> $<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .success(json):</span><br><span class="line">                <span class="keyword">let</span> result = <span class="keyword">try</span>! <span class="type">JSONDecoder</span>().decode(<span class="type">APIResponse</span>&lt;&#123;&#123;type.name&#125;&#125;.<span class="type">ResponseBody</span>&gt;.<span class="keyword">self</span>, from: json!)</span><br><span class="line">                completion(.success(result.body))</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .failure(error): completion(.failure(error))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">#endif</span><br><span class="line">&#123;٪endif%&#125;</span><br><span class="line">&#123;٪endmacro%&#125;</span><br></pre></td></tr></table></figure><p>这样就能尽可能使请求方法模板看起来更干净一些。尽管生成的代码是挺丑的，不过谁要去管它们呢。</p><p>很遗憾 Sourcery 好像还并不支持 <code>indent</code> 这个 filter，所以当缩进有点深的时候，模板会变得很难看（尽管官方好像说是支持的）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不太喜欢现在公司项目中 API Client 的实现方式，虽然并没有什么问题，但我还是忍不住要重构一下。原本的实现是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SomeModel&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)doSomething:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)aParam completion:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^)(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; isSuccess, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *errorMessage, SomeModel * someModel))completion &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [APIClient.sharedClient &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        POST:someEndpoint&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parameters: @&amp;#123; &lt;span class=&quot;string&quot;&gt;@&quot;p&quot;&lt;/span&gt;: aParam &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        success:^(&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; * _Nonnull task, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;  _Nullable responseObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            PPApiResponseObject *responseItem = [PPApiResponseObject createFrom:responseObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (responseItem.isSuccess) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        failure:^(&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; * _Nullable task, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nonnull error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有几个地方是我不喜欢的：1. 用 Objective C 写的；2. API 不太现代；3. endpoint 分散在了不同的 model 定义里面；4. 重复的东西太多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Objective C" scheme="http://intii.com/tags/Objective-C/"/>
    
      <category term="Sourcery" scheme="http://intii.com/tags/Sourcery/"/>
    
      <category term="Meta Programming" scheme="http://intii.com/tags/Meta-Programming/"/>
    
      <category term="元编程" scheme="http://intii.com/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="重构" scheme="http://intii.com/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>接手别人的项目</title>
    <link href="http://intii.com/2018/refactoring-others-project-001/"/>
    <id>http://intii.com/2018/refactoring-others-project-001/</id>
    <published>2018-06-09T03:21:00.000Z</published>
    <updated>2018-11-25T14:20:17.742Z</updated>
    
    <content type="html"><![CDATA[<p>在城大的工作终于是结束了。用了「终于」两个字，是因为我再也不能承受这份工作了，虽然他们允许我远程工作，在工作中我的时间安排相当自由，做的内容也是比较自由，但是正因为太自由了，我发现我在里面投入了过多的时间与精力——描述太过「简单」的需求让我很难界定范围。而教授又希望他的 app 能够「充满不同游戏」，这个状态一直都在持续。</p><p>于是我找了一份朝九晚六周末休息、离家还算近的工作。一切都还挺好的，只是接手代码这件事让我有些难受。</p><a id="more"></a><p>先谈谈这个项目有什么问题。</p><h2 id="Massive-View-Controller"><a href="#Massive-View-Controller" class="headerlink" title="Massive View Controller"></a>Massive View Controller</h2><p>每个页面基本上就是靠着一个 view controller 撑着，业务逻辑和 UI 逻辑混在一起，我看到过一个 2000+ 行的。</p><h2 id="不够-MVC"><a href="#不够-MVC" class="headerlink" title="不够 MVC"></a>不够 MVC</h2><p>这个项目里 view 绝对是「一等公民」。view 不仅能够控制页面跳转，有时还承担了一些业务逻辑。</p><p>将这些放到 view 去做就算了，还偷懒不给足够的上下文。之前就遇到了一个遗留 bug：一个弹窗弹到了错误的地方。原因是弹窗的逻辑写到了 view 里，而 view 竟然将弹窗作为 subview 加到了 <code>[[[[UIApplication sharedApplication] delegate] window] rootViewController].view</code> 上，显然在某一版之前这个逻辑（恰好）是正确的，某一版之后他们决定不把这个页面 push 到作为 <code>rootViewcontroller</code> 的 navigation controller 里面了，就出现了这个问题。<br><img src="/media/refactoring-others-project-001/incorrect-position-of-popup.png" alt="incorrect-position-of-popup"></p><p>我猜这个 bug 已经存在很久了……这种写法也为接手的人带来了极大的困难，现在我需要每个 view 都点开看看才知道发生了什么。</p><h2 id="View-的依赖太随便"><a href="#View-的依赖太随便" class="headerlink" title="View 的依赖太随便"></a>View 的依赖太随便</h2><p><img src="/media/refactoring-others-project-001/better-way-to-pass-dependency-1.png" alt="better-way-to-pass-dependency"></p><p>有些时候上下文也是给得太足。比如说有这么一个 cell，本来传进去三样东西就足够了，在这个项目中却为了写时方便传入了硕大无比的 object，再在 cell 的内部决定使用什么内容。<br><img src="/media/refactoring-others-project-001/wrong-way-to-pass-dependency-1.png" alt="wrong-way-to-pass-dependency"></p><p>对于没有接触过这个项目的人来说很难去理清究竟用了什么没用什么，我甚至会担心把这个 mutable 的东西传来传去，会不会发生了什么意料之外的写操作。另外就是要单独测试这个 cell 的话，就需要先去创建这样的一个巨大 object 了，很麻烦。</p><h2 id="充满了-Magic-Value"><a href="#充满了-Magic-Value" class="headerlink" title="充满了 Magic Value"></a>充满了 Magic Value</h2><p>这次是中途接手了别人的 0.1.0 级别更新，我没有时间先大概了解这个项目和这个版本的需求，就要开始写代码了。到了最后一天的下午，设计师突然跟我说要把某个间距从 15 改成 20。这当然应该是很简单的事情，可却把我给难住了，因为这个间距所在的 <code>UICollectionViewCell</code> 的高度计算方法里是这种样子的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> height = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">height += <span class="number">15</span> + somethingsHeight + <span class="number">20</span> + <span class="number">5</span> + <span class="number">10</span> + <span class="number">15</span>;</span><br><span class="line">...</span><br><span class="line">height += anotherHeight + <span class="number">20</span> + <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (showThis) &#123; height += <span class="number">5</span> + thisHeight + <span class="number">20</span> + <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br></pre></td></tr></table></figure><p>更可怕的是，我尝试去改了一下数字，界面却没有发生变化。对不起，我只能想办法让它变宽一些，具体宽多少，我暂时还没有办法控制，等下一版吧。</p><p>在 iPhone X 的适配上也是使用了判断机型提供相应 magic value 的方式，我已经预感到下一次适配时的痛苦了。</p><h2 id="太喜欢宏定义"><a href="#太喜欢宏定义" class="headerlink" title="太喜欢宏定义"></a>太喜欢宏定义</h2><p>并不是说宏定义不好，我也喜欢用宏定义来实现 Objc 下的 let 和 var，但是有些常量实际上用其他方式来表示会更好一些。比如说颜色，这个项目有一个主题色被定义成了常量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define GLOBAL_TINTCOLOR UIColorFromRGB(0x12abcd)</span></span><br></pre></td></tr></table></figure><p>我总是不记得这个宏叫什么，因为还存在很多其它名称各异的颜色常量，叫做 <code>XXXX_COLOR</code>、<code>XXXX_COLOR_XXX</code> 或者 <code>ColorForXXXXX</code>，甚至还有 <code>COLOR_0xAAAAAA</code> 这样的东西。要说它们命名能规范一些、定义能集中一些，问题倒是不大，但它们基本上是东一个西一个，名称格式也各式各样，除非记得名字，想找到它们还是很麻烦的，自动补全都帮不了你。</p><p>其实写成 <code>UIColor</code> 的 category 不就完了嘛。</p><h2 id="太多-Warning"><a href="#太多-Warning" class="headerlink" title="太多 Warning"></a>太多 Warning</h2><p>我第一次 build 这个项目的时候真是惊呆了，300 多个 warning，其中可能有一半是因为用了 iOS 9 或之前开始 deprecate 的 API。我掐指一算，9、10、11、12，这些难道不应该两年前就清掉吗，反倒还在继续用。我也没法现在就动手把它们全部改掉，只好先写个 wrapper 把它们都包住，关掉 deprecated functions 的 warning，日后再统一处理。</p><p>然后还有很多「Prototype xxx cells must have reuse identifiers」，我猜是上面的一百来个 warning 蒙蔽了他的双眼。还有一些「隐式类型转换可能会影响精度」啊、类型不匹配啊、或者输入了奇怪的符号但会被当作空格……能改的我都改了，还有一些莫名其妙的、不敢改的、来自第三方库的，现在还有 46 个 warning。</p><p>看到这么多 warning，你们就不心疼？心疼是小事，重要的 warning 被淹没了可是大事。</p><h2 id="太喜欢第三方库，尤其是-UI-方面"><a href="#太喜欢第三方库，尤其是-UI-方面" class="headerlink" title="太喜欢第三方库，尤其是 UI 方面"></a>太喜欢第三方库，尤其是 UI 方面</h2><p>用是可以的，但能不能不要挑那种没有 star、上传之后就没下文的库呢。这种库往往都没法开箱即用，拖下来也是一顿改。这读别人代码然后强行改成符合需求的时间，我觉得自己写早写完了，最终效果和过程体验都得好不少。</p><p>而对于一个接手项目的人来说，读这种充满补丁的代码更是噩梦。</p><h2 id="干脆就复制粘贴吧"><a href="#干脆就复制粘贴吧" class="headerlink" title="干脆就复制粘贴吧"></a>干脆就复制粘贴吧</h2><p>项目里充满了内部复制粘贴的代码。在很多情况下，复制粘贴其实还不错。但像以下这种类型的复制粘贴真的是非常糟糕了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SomeViewController *vc = [SomeViewController new];</span><br><span class="line">[vc initializeWithSomeProperties];</span><br><span class="line"><span class="built_in">UINavigationController</span> *nav = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:vc];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:nav];</span><br></pre></td></tr></table></figure><p><strong>天知道这要包在一个 <code>UINavigationController</code> 里面噢。</strong></p><p>这种情况，把 <code>SomeViewController</code> 直接做成一个 <code>UINavigationController</code> 或者是用一个 navigation coordinator 来控制跳转，怕不是要强个一百倍。</p><p>这种代码的复制粘贴还有不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在城大的工作终于是结束了。用了「终于」两个字，是因为我再也不能承受这份工作了，虽然他们允许我远程工作，在工作中我的时间安排相当自由，做的内容也是比较自由，但是正因为太自由了，我发现我在里面投入了过多的时间与精力——描述太过「简单」的需求让我很难界定范围。而教授又希望他的 app 能够「充满不同游戏」，这个状态一直都在持续。&lt;/p&gt;
&lt;p&gt;于是我找了一份朝九晚六周末休息、离家还算近的工作。一切都还挺好的，只是接手代码这件事让我有些难受。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://intii.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>如何引用一个值类型属性</title>
    <link href="http://intii.com/2018/how-to-reference-to-a-value-type-property/"/>
    <id>http://intii.com/2018/how-to-reference-to-a-value-type-property/</id>
    <published>2018-04-02T06:06:55.000Z</published>
    <updated>2018-04-02T06:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在更新 Best Before 的过程中，我决定重写 <code>ForwardStrategy</code> 的部分。过去 <code>ForwardStrategy</code> 中不同的转发目标所储存的信息其实是一样的，只是不同的转发目标会隐藏其不包含的属性。因此其对应的表单也是这样设计的，表单中其实包含了所有属性对应的 cell，但是在选中某些目标时，其中一些 cell 被隐藏起来了。</p><p>举个例子吧：比如说我们有 Things 和 Mail 两种转发目标，当我们选中 Things 时，因为它并没有收件人，所以其对应的 cell 被隐藏起来了。当我们切换到 Mail，收件人就得以重见天日，但截止日期却被隐藏起来了。这个方案当然是 work 的，但是却有一个明显的缺点，一旦我们需要添加新的转发目标，或更新旧有的转发目标时出现了新的属性时，我们就需要修改模型，并在表单中增加新的 cell 了。</p><p>因此在这次更新中，我决定将转发目标的属性以 JSON 为格式储存，这也避免了不同转发目标混用属性的尴尬。表单方面也需要作出修改。窒息观察可以发现，这些属性有几个固定的类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ForwardFormElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> highlightTextView(title: <span class="type">String</span>, placeholder: <span class="type">String</span>?, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> textView(title: <span class="type">String</span>, placeholder: <span class="type">String</span>?, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> textField(title: <span class="type">String</span>, placeholder: <span class="type">String</span>?, keyboardType: <span class="type">UIKeyboardType</span>, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">String</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> picker(title: <span class="type">String</span>, options: [<span class="type">String</span>], bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">Int</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> toggle(title: <span class="type">String</span>, bind: <span class="type">PropertyRefTo</span>&lt;<span class="type">Bool</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要提供每一种转发目标的 <code>[ForwardFormElement]</code>，就能依次利用 Form Builder 生成相应的表单了。同时也为了契合我在用的 Form Builder 的特点，我希望在生成每一个 <code>Row</code> 时能够通过它的 <code>onChange</code> 方法将变动绑定到转发目标的相关属性上。这才有了本篇文章的主题。</p><a id="more"></a><p>先梳理一下，我希望的结果是：</p><ol><li>转发目标提供 <code>[ForwardFormElement]</code> 给 Form Builder</li><li>ForwardFormElement 中包含了一个对转发目标属性的弱引用</li><li>Form Builder 生成 <code>Row</code> 时通过 <code>onChange</code> 方法绑定属性<br> <code>row.onChange { bind.val = $0 }</code></li><li><code>bind.val</code> 改变时同时改变转发目标的相关属性（很可能是值类型）</li></ol><p>那么接下来就是怎么实现 <code>bind: PropertyRefTo&lt;T&gt;</code> 的问题了。</p><p>很简单，Swift 4 给我们带来了 KeyPath subscription，只要我们持有转发目标的弱引用，然后再存对应的 KeyPath 就好了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropertyRefTo</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val: <span class="type">V</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyRef</span>&lt;<span class="title">O</span>: <span class="title">AnyObject</span>, <span class="title">V</span>&gt;: <span class="title">PropertyRefTo</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> object: <span class="type">O</span>?</span><br><span class="line">    <span class="keyword">let</span> keyPath: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">O</span>, <span class="type">V</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">O</span>, <span class="number">_</span> keyPath: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">O</span>, <span class="type">V</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.object = object</span><br><span class="line">        <span class="keyword">self</span>.keyPath = keyPath</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> val: <span class="type">V</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> object?[keyPath: keyPath]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> v = newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            object?[keyPath: keyPath] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能用吗？能用。但是我还有一个额外的需求，有一些对应 <code>case picker(title: String, options: [String], bind: PropertyRefTo&lt;Int&gt;)</code> 的属性是 Enum，但 Swift 并没有 Generic Case 这样的东西，所以我们要让 <code>PropertyRef</code> 能够按照我们的要求将其 <code>val</code> 转换成我们需要的类型。显而易见，不提供 <code>object</code> 和 <code>keyPath</code>，而是提供 <code>val</code> 的 getter 和 setter 不就好了吗。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">O</span>, getter: @escaping (<span class="type">O</span>)-&gt;<span class="type">V</span>?, setter: @escaping (<span class="type">O</span>, <span class="type">V</span>)-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.getter = &#123;</span><br><span class="line">        [<span class="keyword">weak</span> object] <span class="keyword">in</span> <span class="keyword">guard</span> <span class="keyword">let</span> object = object <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> getter(object)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.setter = &#123;</span><br><span class="line">        [<span class="keyword">weak</span> object] newValue <span class="keyword">in</span> <span class="keyword">guard</span> <span class="keyword">let</span> object = object <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        setter(object, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 block 里通过 capture list 弱引用 <code>object</code>，因为这么写了，所以我们要求 <code>O: AnyObject</code>。最后 Key Path 这种这么方便的东西，我们也可以提供一个 convenience initializer。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">O</span>, <span class="number">_</span> keyPath: <span class="type">ReferenceWritableKeyPath</span>&lt;<span class="type">O</span>, <span class="type">V</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(object, getter: &#123; $<span class="number">0</span>[keyPath: keyPath] &#125;, setter: &#123; $<span class="number">0</span>[keyPath: keyPath] = $<span class="number">1</span> &#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们就能获得一个 <code>AnyObject</code> 的非引用类型的属性的引用啦。</p><p>随后代码就可以写成</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.highlightTextView(</span><br><span class="line">    title: <span class="type">Localized</span>.<span class="type">This</span>.<span class="type">Form</span>.<span class="type">Things</span>.notes, </span><br><span class="line">    placeholder: <span class="type">Localized</span>.<span class="type">This</span>.<span class="type">Form</span>.<span class="type">Things</span>.notesPlaceholder, </span><br><span class="line">    bind: <span class="type">PropertyRef</span>(<span class="keyword">self</span>, \.notes)),</span><br><span class="line">.picker(</span><br><span class="line">    title: <span class="type">Localized</span>.<span class="type">This</span>.<span class="type">Form</span>.<span class="type">Things</span>.deadline, </span><br><span class="line">    options: <span class="type">DeadlineType</span>.allTitles,</span><br><span class="line">    bind: <span class="type">PropertyRef</span>(<span class="keyword">self</span>, getter: &#123; $<span class="number">0</span>.deadlineType.identifier &#125;</span><br><span class="line">                            setter: &#123; $<span class="number">0</span>.deadlineType = <span class="type">DeadlineType</span>(identifier: $<span class="number">1</span>) &#125;)),</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在更新 Best Before 的过程中，我决定重写 &lt;code&gt;ForwardStrategy&lt;/code&gt; 的部分。过去 &lt;code&gt;ForwardStrategy&lt;/code&gt; 中不同的转发目标所储存的信息其实是一样的，只是不同的转发目标会隐藏其不包含的属性。因此其对应的表单也是这样设计的，表单中其实包含了所有属性对应的 cell，但是在选中某些目标时，其中一些 cell 被隐藏起来了。&lt;/p&gt;
&lt;p&gt;举个例子吧：比如说我们有 Things 和 Mail 两种转发目标，当我们选中 Things 时，因为它并没有收件人，所以其对应的 cell 被隐藏起来了。当我们切换到 Mail，收件人就得以重见天日，但截止日期却被隐藏起来了。这个方案当然是 work 的，但是却有一个明显的缺点，一旦我们需要添加新的转发目标，或更新旧有的转发目标时出现了新的属性时，我们就需要修改模型，并在表单中增加新的 cell 了。&lt;/p&gt;
&lt;p&gt;因此在这次更新中，我决定将转发目标的属性以 JSON 为格式储存，这也避免了不同转发目标混用属性的尴尬。表单方面也需要作出修改。窒息观察可以发现，这些属性有几个固定的类型：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ForwardFormElement&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; highlightTextView(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, placeholder: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; textView(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, placeholder: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; textField(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, placeholder: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;?, keyboardType: &lt;span class=&quot;type&quot;&gt;UIKeyboardType&lt;/span&gt;, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; picker(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, options: [&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;], bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; toggle(title: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, bind: &lt;span class=&quot;type&quot;&gt;PropertyRefTo&lt;/span&gt;&amp;lt;&lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们只需要提供每一种转发目标的 &lt;code&gt;[ForwardFormElement]&lt;/code&gt;，就能依次利用 Form Builder 生成相应的表单了。同时也为了契合我在用的 Form Builder 的特点，我希望在生成每一个 &lt;code&gt;Row&lt;/code&gt; 时能够通过它的 &lt;code&gt;onChange&lt;/code&gt; 方法将变动绑定到转发目标的相关属性上。这才有了本篇文章的主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="KeyPath" scheme="http://intii.com/tags/KeyPath/"/>
    
      <category term="ReferenceWritableKeyPath" scheme="http://intii.com/tags/ReferenceWritableKeyPath/"/>
    
      <category term="Reference" scheme="http://intii.com/tags/Reference/"/>
    
      <category term="Value Type" scheme="http://intii.com/tags/Value-Type/"/>
    
  </entry>
  
  <entry>
    <title>用 Blend Mode 来让 Navigation Bar 骚气起来</title>
    <link href="http://intii.com/2018/decorate-uinavigationbar-with-blend-mode/"/>
    <id>http://intii.com/2018/decorate-uinavigationbar-with-blend-mode/</id>
    <published>2018-03-13T06:21:00.000Z</published>
    <updated>2018-11-25T14:17:27.810Z</updated>
    
    <content type="html"><![CDATA[<p>最近又在更新 Best Before.app，算是把同步写好了，但是还是打算顺便更新一下 UI。之前加入了自定义分类的功能，还允许用户给分类设置一个颜色，但是这个颜色却没有什么实际的作用，在这次更新中我打算在 Navigation Bar 上面显示出这个颜色。</p><p><img src="/media/decorate-uinavigationbar-with-blend-mode/old.png" width="375px" alt="old"/></p><p>应该怎么显示呢，一开始我的想法是让分类名称的第一个字符设置为这个颜色。尽管 <code>UINavigationBar</code> 并没有给我们提供一个 API 去做这个事情，我们还是能够很暴力地从其众多的 <code>subviews</code> 的 <code>subviews</code> 当中，找到这些 <code>UILabel</code>。如果 iOS 还没到 11，这就足够了，但是 iOS 11 中却引入了 Large Title，而即便我们修改了 Large Title 的 <code>attributedString</code>，它也会在我们拖动底下的 scroll view 时打回原形。</p><p>很讨厌。</p><a id="more"></a><p>这时我想起了 Sketch 中 Blend Mode，在 Sketch 用 Blend Mode Lighten 能够将颜色附着在图标上，虽然没法简单地定位到刚好只覆盖到第一个字符，但好像也挺拉风的，于是我在 Sketch 里面做了一些修改。</p><p><img src="/media/decorate-uinavigationbar-with-blend-mode/new.png" width="375px" alt="new"/></p><p>那 iOS 上是否有这样的功能呢。</p><p>居然有，我们只需要在 <code>UINavigationBar</code> 上添加一个 <code>CALayer</code>，并将其的 <code>compositingFilter</code> 赋值为 <code>lightenBlendMode</code> 就可以了。同时还要 observe Navigation Bar 的 <code>frame</code> 以随着它的高度变动修改这个 layer 的 <code>path</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNavigationBarBlending</span><span class="params">()</span></span> &#123;</span><br><span class="line">    blendLayer = &#123;</span><br><span class="line">        <span class="keyword">let</span> it = <span class="type">CAShapeLayer</span>()</span><br><span class="line">        it.compositingFilter = <span class="string">"lightenBlendMode"</span></span><br><span class="line">        navigationBar.layer.addSublayer(it)</span><br><span class="line">        <span class="keyword">let</span> observation = navigationBar.observe(\.frame) &#123; bar, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            it.path = <span class="type">UIBezierPath</span>(rect: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, </span><br><span class="line">                                                width: <span class="number">50</span>, </span><br><span class="line">                                                height: bar.frame.height)).cgPath</span><br><span class="line">        &#125;</span><br><span class="line">        disposables.append(observation)</span><br><span class="line">        <span class="keyword">return</span> it</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要在显示分类列表时，修改 <code>blendLayer</code> 的 <code>fillColor</code> 就行了。值得一提的是 <code>UINavigationBar.frame</code> 恰好只包含到了 Large Title View，并不包括搜索框。</p><p>当然如果再花些功夫，也还是能让它只覆盖到第一个字符的，但是也没必要了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又在更新 Best Before.app，算是把同步写好了，但是还是打算顺便更新一下 UI。之前加入了自定义分类的功能，还允许用户给分类设置一个颜色，但是这个颜色却没有什么实际的作用，在这次更新中我打算在 Navigation Bar 上面显示出这个颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/decorate-uinavigationbar-with-blend-mode/old.png&quot; width=&quot;375px&quot; alt=&quot;old&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应该怎么显示呢，一开始我的想法是让分类名称的第一个字符设置为这个颜色。尽管 &lt;code&gt;UINavigationBar&lt;/code&gt; 并没有给我们提供一个 API 去做这个事情，我们还是能够很暴力地从其众多的 &lt;code&gt;subviews&lt;/code&gt; 的 &lt;code&gt;subviews&lt;/code&gt; 当中，找到这些 &lt;code&gt;UILabel&lt;/code&gt;。如果 iOS 还没到 11，这就足够了，但是 iOS 11 中却引入了 Large Title，而即便我们修改了 Large Title 的 &lt;code&gt;attributedString&lt;/code&gt;，它也会在我们拖动底下的 scroll view 时打回原形。&lt;/p&gt;
&lt;p&gt;很讨厌。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="UINavigationBar" scheme="http://intii.com/tags/UINavigationBar/"/>
    
      <category term="iOS 11" scheme="http://intii.com/tags/iOS-11/"/>
    
      <category term="Large Title" scheme="http://intii.com/tags/Large-Title/"/>
    
      <category term="Customization" scheme="http://intii.com/tags/Customization/"/>
    
      <category term="Blending Mode" scheme="http://intii.com/tags/Blending-Mode/"/>
    
  </entry>
  
  <entry>
    <title>新头像，超清猎人</title>
    <link href="http://intii.com/2018/avatar-uhd-hunter/"/>
    <id>http://intii.com/2018/avatar-uhd-hunter/</id>
    <published>2018-01-21T10:21:31.000Z</published>
    <updated>2018-03-13T04:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>热烈庆祝 MHW 面世。<br><a id="more"></a><br><img src="/media/avatar-uhd-hunter.jpg" alt="avatar-charge-blade-maste"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;热烈庆祝 MHW 面世。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codable Enum with Associated Values</title>
    <link href="http://intii.com/2017/codable-enum-with-associated-values/"/>
    <id>http://intii.com/2017/codable-enum-with-associated-values/</id>
    <published>2017-10-19T06:21:00.000Z</published>
    <updated>2018-11-25T14:17:27.803Z</updated>
    
    <content type="html"><![CDATA[<p>我们决定在项目中使用 JSON 来储存每一个章节的信息，于是就出现了一个需求，JSON 里面的数组里可能会存在多种 Object，要举个栗子的话，就是一台战舰上可能会同时搭载了一些 Mobile Suits 和 Mobile Armor，而且它们还是放在一块儿的，却又有着不同类型的属性。<br><img src="/media/codable_enum_with_associated_values/msandma.png" width="340px"></p><p>既然我们在用 Swift，就很自然的想用 Enum 来表示它们：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Unit</span>: <span class="title">Codable</span> </span>&#123;            <span class="comment">// &#123;</span></span><br><span class="line">    <span class="keyword">case</span> mobileArmor(           <span class="comment">//   "type": "mobile-armor",</span></span><br><span class="line">        numberOfPilots: <span class="type">Int</span>     <span class="comment">//   "number-of-pilots": 2</span></span><br><span class="line">    )                           <span class="comment">// &#125;,</span></span><br><span class="line">                                <span class="comment">// &#123;</span></span><br><span class="line">    <span class="keyword">case</span> mobileSuit(            <span class="comment">//   "type": "mobile-suit"</span></span><br><span class="line">        numberOfLegs: <span class="type">Int</span>,      <span class="comment">//   "number-of-leg": 2,</span></span><br><span class="line">        isGundam: <span class="type">Bool</span>          <span class="comment">//   "is-gundam": true</span></span><br><span class="line">    )                           <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Mobile Armor，它可能需要好几个驾驶员负责四肢和头部，但对于 Mobile Suit，上头则更在乎它们有多少只脚，以及<ruby>是不是高达<rt>有没有光环</rt></ruby>。当我们直接加上 <code>Codable</code>，Compiler 就报错了，显然我们需要手动做一些什么奇怪的事情才行。</p><a id="more"></a><p>易知，Compiler 没有恰当的手段给我们自动生成 <code>CodingKey</code>，对于普通的 Enum，我们可以指定 Enum 的 raw value 的类型来解决问题，但带有 associated values 的 Enum 则不允许我们这么做，所以我们得手动添加 <code>CodingKey</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> type</span><br><span class="line">    <span class="keyword">case</span> numberOfLegs = <span class="string">"number-of-legs"</span>, isGundam = <span class="string">"is-gundam"</span></span><br><span class="line">    <span class="keyword">case</span> numberOfPilots = <span class="string">"number-of-pilots"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们还需要实现 <code>init(from decoder: Decoder)</code>：  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .type)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">switch</span> type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mobile-suit"</span>:</span><br><span class="line">        <span class="keyword">let</span> numberOfLegs = <span class="keyword">try</span> values.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .numberOfLegs)</span><br><span class="line">        <span class="keyword">let</span> isGundam = <span class="keyword">try</span> values.decode(<span class="type">Bool</span>.<span class="keyword">self</span>, forKey: .isGundam)</span><br><span class="line">        <span class="keyword">self</span> = .mobileSuit(numberOfLegs: numberOfLegs, isGundam: isGundam)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mobile-armor"</span>:</span><br><span class="line">        <span class="keyword">let</span> numberOfPilots = <span class="keyword">try</span> values.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .numberOfPilots)</span><br><span class="line">        <span class="keyword">self</span> = .mobileArmor(numberOfPilots: numberOfPilots)</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="type">UnitError</span>.decoding(<span class="string">"error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样把不同 case 的 coding keys 都放在一起是比较危险的，即便是新人类或者调整者，也不能保证不会手残，在生成 MS 资料的时候去读取了一个不存在的、属于 MA 的 key。所以要是想再 type safe 一些的话，可以把不同 case 的 coding keys 放在不同的 Enum 里面，防止敲错 key：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">MobileArmorCodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> numberOfPilots = <span class="string">"number-of-pilots"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"mobile-armor"</span>:</span><br><span class="line">        <span class="keyword">let</span> values = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">MobileArmorCodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> numberOfPilots = <span class="keyword">try</span> values.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .numberOfPilots)</span><br><span class="line">        <span class="keyword">self</span> = .mobileArmor(numberOfPilots: numberOfPilots)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Encode 部分也是同理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .mobileSuit(numberOfLegs, isGundam):</span><br><span class="line">        <span class="keyword">try</span> container.encode(<span class="string">"mobile-suit"</span>, forKey: .type)</span><br><span class="line">        <span class="keyword">var</span> values = encoder.container(keyedBy: <span class="type">MobileSuitCodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> values.encode(isGundam, forKey: .isGundam)</span><br><span class="line">        <span class="keyword">try</span> values.encode(numberOfLegs, forKey: .numberOfLegs)</span><br><span class="line">    <span class="keyword">case</span> .mobileArmor(<span class="keyword">let</span> numberOfPilots):...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json =＂＂＂</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"mobile-suit"</span>,</span><br><span class="line">        <span class="string">"is-gundam"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"number-of-legs"</span>: <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"mobile-armor"</span>,</span><br><span class="line">        <span class="string">"number-of-pilots"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">＂＂＂</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">try</span>! decoder.decode([<span class="type">Unit</span>].<span class="keyword">self</span>, from: json.data(using: .utf8)!)</span><br><span class="line"><span class="comment">// [Unit.mobileSuit(numberOfLegs: 4, isGundam: true), Unit.mobileArmor(2)]</span></span><br><span class="line"><span class="keyword">let</span> encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span>! encoder.encode(result)</span><br><span class="line"><span class="comment">// [&#123;"type":"mobile-suit","number-of-legs":4,"is-gundam":true&#125;,&#123;"type":"mobile-armor","number-of-pilots":2&#125;]</span></span><br></pre></td></tr></table></figure><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>后来我在别的项目中又遇到了这个需求，并决定用 Sourcery 给我自动生成这些代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% <span class="keyword">for</span> <span class="class"><span class="keyword">enum</span> <span class="title">in</span> <span class="title">types</span>.<span class="title">implementing</span>.<span class="title">AutoCodableEnumWithAssociatedValue</span>|<span class="title">enum</span> %&#125;</span></span><br><span class="line"><span class="class"></span>&#123;% <span class="keyword">if</span> <span class="class"><span class="keyword">enum</span>.<span class="title">hasAssociatedValues</span> %&#125;</span></span><br><span class="line"><span class="class">// <span class="title">MARK</span>: </span>&#123;&#123; <span class="class"><span class="keyword">enum</span>.<span class="title">name</span> &#125;&#125; <span class="title">Codable</span></span></span><br><span class="line"><span class="class"><span class="title">extension</span> </span>&#123;&#123; <span class="class"><span class="keyword">enum</span>.<span class="title">name</span> &#125;&#125;: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> type</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;% <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="class"><span class="keyword">enum</span>.<span class="title">cases</span> %&#125;</span></span><br><span class="line"><span class="class">    </span>&#123;% <span class="keyword">if</span> <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> </span>&#123;&#123;<span class="keyword">case</span>.name | upperFirstLetter&#125;&#125;<span class="type">CodingKeys</span>: <span class="type">String</span>, <span class="type">CodingKey</span> &#123;</span><br><span class="line">        &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">        <span class="keyword">case</span> &#123;&#123; value.localName &#125;&#125; = <span class="string">"&#123;&#123; value.localName | camelToSnakeCase &#125;&#125;"</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> type = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .type)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        &#123;% <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="class"><span class="keyword">enum</span>.<span class="title">cases</span> %&#125;</span></span><br><span class="line"><span class="class">        </span>&#123;% <span class="keyword">if</span> not <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>: <span class="keyword">self</span> = .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;    </span><br><span class="line">        &#123;% endif %&#125;            </span><br><span class="line">        &#123;% <span class="keyword">if</span> <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>:</span><br><span class="line">            <span class="keyword">let</span> values = <span class="keyword">try</span> decoder.container(keyedBy: &#123;&#123;<span class="keyword">case</span>.name | upperFirstLetter&#125;&#125;<span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">            &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">            <span class="keyword">let</span> &#123;&#123;value.localName&#125;&#125; = <span class="keyword">try</span> values.decode(&#123;&#123;value.typeName&#125;&#125;.<span class="keyword">self</span>, forKey: .&#123;&#123;value.localName&#125;&#125;)</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">            <span class="keyword">self</span> = .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;(</span><br><span class="line">                &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">                &#123;&#123;value.localName&#125;&#125;: &#123;&#123;value.localName&#125;&#125;&#123;% <span class="keyword">if</span> not forloop.last %&#125;,&#123;% endif %&#125;</span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line">            )</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="type">EncodingError</span>.invalidValue(type, .<span class="keyword">init</span>(codingPath: [<span class="type">CodingKeys</span>.type], debugDescription: <span class="string">"<span class="subst">\(type)</span> is not found in cases of &#123;&#123;enum.name&#125;&#125;"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        &#123;% <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> <span class="class"><span class="keyword">enum</span>.<span class="title">cases</span> %&#125;</span></span><br><span class="line"><span class="class">        </span>&#123;% <span class="keyword">if</span> not <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;: <span class="keyword">try</span> container.encode(<span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>, forKey: .type)   </span><br><span class="line">        &#123;% endif %&#125;            </span><br><span class="line">        &#123;% <span class="keyword">if</span> <span class="keyword">case</span>.hasAssociatedValue %&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .&#123;&#123;<span class="keyword">case</span>.name&#125;&#125;(&#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;&#123;&#123;value.localName&#125;&#125;&#123;% <span class="keyword">if</span> not forloop.last %&#125;, &#123;% endif %&#125;&#123;% endfor %&#125;):</span><br><span class="line">            <span class="keyword">try</span> container.encode(<span class="string">"&#123;&#123;case.name | camelToSnakeCase&#125;&#125;"</span>, forKey: .type)</span><br><span class="line">            <span class="keyword">var</span> values = encoder.container(keyedBy: &#123;&#123;<span class="keyword">case</span>.name | upperFirstLetter&#125;&#125;<span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">            &#123;% <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">case</span>.associatedValues %&#125;</span><br><span class="line">            <span class="keyword">try</span> values.encode(&#123;&#123;value.localName&#125;&#125;, forKey: .&#123;&#123;value.localName&#125;&#125;)</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们决定在项目中使用 JSON 来储存每一个章节的信息，于是就出现了一个需求，JSON 里面的数组里可能会存在多种 Object，要举个栗子的话，就是一台战舰上可能会同时搭载了一些 Mobile Suits 和 Mobile Armor，而且它们还是放在一块儿的，却又有着不同类型的属性。&lt;br&gt;&lt;img src=&quot;/media/codable_enum_with_associated_values/msandma.png&quot; width=&quot;340px&quot;&gt;&lt;/p&gt;
&lt;p&gt;既然我们在用 Swift，就很自然的想用 Enum 来表示它们：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Unit&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Codable&lt;/span&gt; &lt;/span&gt;&amp;#123;            &lt;span class=&quot;comment&quot;&gt;// &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mobileArmor(           &lt;span class=&quot;comment&quot;&gt;//   &quot;type&quot;: &quot;mobile-armor&quot;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numberOfPilots: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;//   &quot;number-of-pilots&quot;: 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )                           &lt;span class=&quot;comment&quot;&gt;// &amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                &lt;span class=&quot;comment&quot;&gt;// &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mobileSuit(            &lt;span class=&quot;comment&quot;&gt;//   &quot;type&quot;: &quot;mobile-suit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numberOfLegs: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;,      &lt;span class=&quot;comment&quot;&gt;//   &quot;number-of-leg&quot;: 2,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isGundam: &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;          &lt;span class=&quot;comment&quot;&gt;//   &quot;is-gundam&quot;: true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )                           &lt;span class=&quot;comment&quot;&gt;// &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于 Mobile Armor，它可能需要好几个驾驶员负责四肢和头部，但对于 Mobile Suit，上头则更在乎它们有多少只脚，以及&lt;ruby&gt;是不是高达&lt;rt&gt;有没有光环&lt;/rt&gt;&lt;/ruby&gt;。当我们直接加上 &lt;code&gt;Codable&lt;/code&gt;，Compiler 就报错了，显然我们需要手动做一些什么奇怪的事情才行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>像写 Swift 那样写 Objective-C</title>
    <link href="http://intii.com/2017/write-objc-like-writing-swift/"/>
    <id>http://intii.com/2017/write-objc-like-writing-swift/</id>
    <published>2017-08-11T14:23:10.000Z</published>
    <updated>2017-12-20T08:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始工作了，为了配合队友，得写 Objective-C。写 Objective-C 的时候，有一个糟心的地方就是定义一个变量的时候：写下一个变量之前，首先映入我的脑海的是如何优雅地命名这个变量，但我却要先写它的类型；而且这个类型还经常需要写两遍，当这种重复的事情做多了，很容易烦躁起来；还有那个星号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *anElegantView = [<span class="built_in">UIView</span> new];</span><br><span class="line">WaitASecICantRememberThatRightNow *something = array.firstObject;</span><br></pre></td></tr></table></figure><a id="more"></a><p>所幸的是，从 PSPDFKit 团队的文章 <a href="https://pspdfkit.com/blog/2017/even-swiftier-objective-c/">Even Swiftier Objective-C</a> 中可以得知，原来苹果在不知道什么时候给 Objective-C 带来了类型推导，现在我们可以将上面的代码写成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__auto_type anElegantView = [<span class="built_in">UIView</span> new];</span><br><span class="line">__auto_type something = (TheType *)array.firstObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 array 使用了 lightweight generics </span></span><br><span class="line">__auto_type something = array.firstObject;</span><br></pre></td></tr></table></figure><p>这下写法总算和 Swift 相似了一些。PSPDFKit 团队没有停下脚步，又定义了一些宏。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define let __auto_type const</span></span><br><span class="line"><span class="meta">#define var __auto_type </span></span><br><span class="line"></span><br><span class="line">let anElegantView = [<span class="built_in">UIView</span> new];</span><br><span class="line">let something = (TheType *)array.firstObject;</span><br><span class="line">var something = array.firstObject;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anElegantView = <span class="type">UIView</span>()</span><br><span class="line"><span class="keyword">let</span> something: <span class="type">TheType</span> = array.first</span><br><span class="line"><span class="keyword">var</span> something = array.first</span><br></pre></td></tr></table></figure><p>再给 <code>NSArray</code> 和 <code>NSMutableArray</code> 加上 <code>map filter</code> 那些，一下子觉得舒服多了。更多更详细的骚操作请看他们的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始工作了，为了配合队友，得写 Objective-C。写 Objective-C 的时候，有一个糟心的地方就是定义一个变量的时候：写下一个变量之前，首先映入我的脑海的是如何优雅地命名这个变量，但我却要先写它的类型；而且这个类型还经常需要写两遍，当这种重复的事情做多了，很容易烦躁起来；还有那个星号。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *anElegantView = [&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WaitASecICantRememberThatRightNow *something = array.firstObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://intii.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://intii.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://intii.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>也可以这样展示书籍封面？</title>
    <link href="http://intii.com/2017/a-better-way-to-display-a-book-cover-questionmark/"/>
    <id>http://intii.com/2017/a-better-way-to-display-a-book-cover-questionmark/</id>
    <published>2017-04-28T14:30:13.000Z</published>
    <updated>2018-11-25T14:18:57.431Z</updated>
    
    <content type="html"><![CDATA[<p>上周赶着要交一个作业，原本是想着开新的项目写一部分交上去的，后来进度太糟糕，就打算另辟蹊径。只剩下几天时间，偶然看 Dribbble 的时候看到了一个豆瓣图书的客户端，觉得要不写个扫码获取书本资料的 app 吧，简单，又符合题意，又能顺便写写 Objective-C 练习一下，便以 <code>Book Shelf</code> 为关键词在 Dribbble 上搜索一番，发现<a href="https://dribbble.com/shots/3116835-Bookshelf">有个设计</a>很棒。它展示的书籍封面是立体的，打开大图仔细一看，发现事情没有那么简单，看起来像是在一张平面的封面上，切了角，打了高光加了阴影，却高大上了许多。</p><p>先是在 Sketch 里面试了试。</p><object class="svg" style="width: 100%;" data="/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.svg" type="image/svg+xml"><br>  <img src="/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.png" /><br></object><a id="more"></a><p>具体实现简单粗暴，就是<a href="https://github.com/int123c/StallApp/blob/master/Stall/BookView.m">上面罩了一堆 <code>CALayer</code></a>（</p><p>具体效果：<br><img src="/media/a-better-way-to-display-a-book-cover-questionmark/IMG_2204.png" style="width:400px;" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周赶着要交一个作业，原本是想着开新的项目写一部分交上去的，后来进度太糟糕，就打算另辟蹊径。只剩下几天时间，偶然看 Dribbble 的时候看到了一个豆瓣图书的客户端，觉得要不写个扫码获取书本资料的 app 吧，简单，又符合题意，又能顺便写写 Objective-C 练习一下，便以 &lt;code&gt;Book Shelf&lt;/code&gt; 为关键词在 Dribbble 上搜索一番，发现&lt;a href=&quot;https://dribbble.com/shots/3116835-Bookshelf&quot;&gt;有个设计&lt;/a&gt;很棒。它展示的书籍封面是立体的，打开大图仔细一看，发现事情没有那么简单，看起来像是在一张平面的封面上，切了角，打了高光加了阴影，却高大上了许多。&lt;/p&gt;
&lt;p&gt;先是在 Sketch 里面试了试。&lt;/p&gt;
&lt;object class=&quot;svg&quot; style=&quot;width: 100%;&quot; data=&quot;/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;br&gt;  &lt;img src=&quot;/media/a-better-way-to-display-a-book-cover-questionmark/displaying-book-cover.png&quot; /&gt;&lt;br&gt;&lt;/object&gt;
    
    </summary>
    
    
      <category term="Design" scheme="http://intii.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>新头像，盾斧使</title>
    <link href="http://intii.com/2017/new-avatar-charge-blade-master/"/>
    <id>http://intii.com/2017/new-avatar-charge-blade-master/</id>
    <published>2017-03-08T10:21:31.000Z</published>
    <updated>2017-04-27T04:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>还有十天 MHXX 就要发售了，非常地期待，于是最近坐火车的时候都会掏出 3DS 来玩玩 MHX。MHX 里面最喜欢的武器还是盾斧，刚开始玩的时候用的都是武士道风格，最近试了试强袭风格，觉得还是挺不错的。</p><p>这次的头像参考了某雌火龙套装 + 盾斧的手办，虽然只带了头盔，<del>但居然也是女装哦</del>。武器看起来是工会盾斧，没有认真画，歪七扭八的。<br><a id="more"></a></p><p><img src="/media/avatar-charge-blade-master.jpg" alt="avatar-charge-blade-maste"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还有十天 MHXX 就要发售了，非常地期待，于是最近坐火车的时候都会掏出 3DS 来玩玩 MHX。MHX 里面最喜欢的武器还是盾斧，刚开始玩的时候用的都是武士道风格，最近试了试强袭风格，觉得还是挺不错的。&lt;/p&gt;
&lt;p&gt;这次的头像参考了某雌火龙套装 + 盾斧的手办，虽然只带了头盔，&lt;del&gt;但居然也是女装哦&lt;/del&gt;。武器看起来是工会盾斧，没有认真画，歪七扭八的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>将豆瓣收藏保存到 Day One 的一个正确方式</title>
    <link href="http://intii.com/2017/saving-douban-fav-to-dayone-the-correct-way/"/>
    <id>http://intii.com/2017/saving-douban-fav-to-dayone-the-correct-way/</id>
    <published>2017-01-23T15:30:52.000Z</published>
    <updated>2017-01-24T06:21:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知道豆瓣是怎么考虑的，豆瓣收藏的 RSS 并没有给出电影海报／书封面的大图，每次看到 Day One 里存了的那张迷你海报就不舒服( ･᷄ὢ･᷅ )。有一个曲线救国的方式是将豆瓣收藏同步到新浪微博，再用 IFTTT 将新浪微博同步到 Day One 里。然而我不用新浪微博很久了，突然在上面发些什么东西总觉得有些不妥，而且这个方法要求在收藏的时候添加一个 tag 以区别它们与其它微博，不够干爽。</p><p>突然今天看到<a href="http://www.appinn.com/integromat/">小众软件推荐了 Integromat</a>，这个产品类似于 IFTTT，但能串联很多任务，甚至包括了正则表达式匹配，再配合 IFTTT 就能将拥有大图的豆瓣收藏保存到 Day One 里了。</p><a id="more"></a><p>豆瓣开放给任意人使用的电影／图书信息 API 里并没有包含大图的链接，但仔细看能够发现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 电影</span><br><span class="line">img3.doubanio.com/view/movie_poster_cover/ipst/public/p2391300344.jpg // 小图</span><br><span class="line">img3.doubanio.com/view/movie_poster_cover/lpst/public/p2391300344.jpg // 大图</span><br><span class="line"></span><br><span class="line">// 图书</span><br><span class="line">img3.doubanio.com/spic/s28416025.jpg // 小图</span><br><span class="line">img3.doubanio.com/lpic/s28416025.jpg // 大图</span><br></pre></td></tr></table></figure><p>不就差了一个字母而已嘛可恶。你看到是哪个字母了吗可恶。</p><p>所以只需要在 Integromat 里用正则表达式匹配前后两部分再拼起来再利用 IFTTT Maker channel 发送到 Day One 就可以了。简直浪费人生。</p><p><del>Integromat 的客服不错，之前我正则表达式写错了他们还帮我改好了（</del></p><p>干这种事情用免费版就足够了。</p><p><img src="http://o7kolop30.bkt.clouddn.com/Screen Shot 2017-01-23 at 11.28.29 PM-1.png" alt="Scenario in Integromat"></p><p>最后终于能看到大图啦好高兴。</p><p><img src="http://o7kolop30.bkt.clouddn.com/Screen Shot 2017-01-23 at 11.24.32 PM.png" alt="Douban Fav with Large Album Picture"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道豆瓣是怎么考虑的，豆瓣收藏的 RSS 并没有给出电影海报／书封面的大图，每次看到 Day One 里存了的那张迷你海报就不舒服( ･᷄ὢ･᷅ )。有一个曲线救国的方式是将豆瓣收藏同步到新浪微博，再用 IFTTT 将新浪微博同步到 Day One 里。然而我不用新浪微博很久了，突然在上面发些什么东西总觉得有些不妥，而且这个方法要求在收藏的时候添加一个 tag 以区别它们与其它微博，不够干爽。&lt;/p&gt;
&lt;p&gt;突然今天看到&lt;a href=&quot;http://www.appinn.com/integromat/&quot;&gt;小众软件推荐了 Integromat&lt;/a&gt;，这个产品类似于 IFTTT，但能串联很多任务，甚至包括了正则表达式匹配，再配合 IFTTT 就能将拥有大图的豆瓣收藏保存到 Day One 里了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016 年总结</title>
    <link href="http://intii.com/2016/summary-of-2016/"/>
    <id>http://intii.com/2016/summary-of-2016/</id>
    <published>2016-12-30T13:37:32.000Z</published>
    <updated>2016-12-30T15:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如同往常一样，今年定下了很多目标，达成了没几个，很多遗憾。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如同往常一样，今年定下了很多目标，达成了没几个，很多遗憾。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新头像，Explosion</title>
    <link href="http://intii.com/2016/avatar-megumin-explosion/"/>
    <id>http://intii.com/2016/avatar-megumin-explosion/</id>
    <published>2016-12-20T15:02:40.000Z</published>
    <updated>2016-12-30T15:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了庆祝《为美好的世界献上祝福》第二季即将在一月开播，所以做了个惠惠版的头像。想要加入一些动作，头像主要参考了惠惠官方粘土人的宣传画。惠惠真是太棒了。<br><a id="more"></a></p><p><img src="/media/avatar-megumin.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了庆祝《为美好的世界献上祝福》第二季即将在一月开播，所以做了个惠惠版的头像。想要加入一些动作，头像主要参考了惠惠官方粘土人的宣传画。惠惠真是太棒了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>新头像，从寨大毕业</title>
    <link href="http://intii.com/2016/avatar-graduation-2016/"/>
    <id>http://intii.com/2016/avatar-graduation-2016/</id>
    <published>2016-04-18T11:58:45.000Z</published>
    <updated>2016-12-27T13:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>一不小心，就要从寨大毕业了。</p><a id="more"></a><p><img src="/media/avatar-graduation-2016.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一不小心，就要从寨大毕业了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
