<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 稍微有点响应式编程 · INTITNI BLOG</title><meta name="description" content="稍微有点响应式编程 - Shangxin Guo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="search" type="application/opensearchdescription+xml" href="http://intii.com/atom.xml" title="INTITNI BLOG"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link shake"><img src="/Logo.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="https://twitter.com/intitni" target="_blank" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/intitni" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">稍微有点响应式编程</h1><div class="post-info">Mar 13, 2019</div><div class="post-content"><p>一开始我其实只是想用 KVO 让 View Model 更响应式一些，可是 KVO 只支持 NSObject，用起来绑手绑脚，感觉没法进行下去。以前看过一些响应式的代码，想要模仿一下它们的风格。感觉要是有这么两个类型就好了：</p>
<ol>
<li><code>Observable&lt;T&gt;</code>，它内部持有一个变量，当这个变量发生改变时，通知其观察者。</li>
<li><code>Emitter&lt;T&gt;</code>，当 ViewModel 发生了什么需要告知 ViewController 时，可以通过 <code>Emitter</code> 发送一个事件，通知其所有的观察者。</li>
</ol>
<p>譬如说我们要写一个掷骰子的程序，这个程序最奇特的一处是当我们多次掷到的数字之和超过 36，就会弹出一个弹窗告诉我们掷到了 36。我们的 ViewModel 可以这样子写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> thirtySix = <span class="type">Emitter</span>&lt;<span class="type">Void</span>&gt;(())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newNum = <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">1</span>...<span class="number">6</span>)</span><br><span class="line">        num.val = newNum</span><br><span class="line">        sum += newNum</span><br><span class="line">        <span class="keyword">if</span> sum &gt;= <span class="number">36</span> &#123; thirtySix.emit(()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如此一来 ViewController 就可以通过监听 <code>num</code> 现实当前掷到的数字和 <code>thirtySix</code> 来得知应该合适显示弹窗了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> viewModel = <span class="type">ViewModel</span>()</span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        viewModel.num.subscribe &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] num <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.label.text = <span class="string">&quot;\(num)&quot;</span></span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        viewModel.thirtySix.subscribe &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.alert()</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就如同 KVO 那样，我们监听之后，总需要有个什么东西持有这个 block，自然而然的，我们就需要这个东西能够在恰当的时候被释放，这样 block 就不会一直被执行了。像各种各样的响应式框架那样，这种东西应该被叫做 <code>Disposable</code>，它有一个 <code>dispose</code> 方法，能够消除监听效果。</p>
<p>说起 KVO，我们不妨用 <code>Disposable</code> 包装一下 <code>NSKeyValueObservation</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObjectProtocol</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;V&gt;<span class="params">(<span class="number">_</span> keyPath: KeyPath&lt;<span class="keyword">Self</span>, V&gt;, onChange: @escaping <span class="params">(V, V?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> observation = observe(keyPath, options: [.initial, .new]) &#123; <span class="number">_</span>, change <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newValue = change.newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            onChange(newValue, change.oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span> &#123; observation.invalidate() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写着写着我们就大概清楚 <code>Disposable</code> 应该如何实现了。而且 <code>Disposable</code> 不仅具有取消监听的作用，它还持有了 <code>NSKeyValueObservation</code> 的强引用，也就是说只要我们持有了 <code>Disposable</code>，也就自然持有了 <code>NSKeyValueObservation</code>。同样的道理，我们也可以将 <code>UIControl</code> 的 <code>addTarget</code> 或者 <code>NotificationCenter</code> 通过这种方式进行监听，这样我们就能通过 <code>DisposeBag</code> 统一管理了。</p>
<p>那属于 <code>Observable&lt;V&gt;</code> 和 <code>Emitter&lt;V&gt;</code> 的 <code>NSKeyValueObservation</code> 又是什么呢？在这里我们就再引入一个类吧。姑且叫它 <code>Observation&lt;V&gt;</code> 吧。</p>
<p>对于一个 <code>Observation</code>，它可以接受一个事件 <code>Event</code>，并将这个 <code>Event</code> 传递给 subscriber。事件的定义很简单，它既可以是一个新值，也可以是一次错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">V</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observation</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PossibleEvent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> next</span><br><span class="line">        <span class="keyword">case</span> failure</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> observers = [(<span class="type">String</span>, (<span class="type">Event</span>) -&gt; <span class="type">Void</span>)]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> latestEvent: <span class="type">Event</span>&lt;<span class="type">V</span>&gt;? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">deinit</span> &#123; disposeBag.dispose() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(<span class="number">_</span> event: Event&lt;V&gt;)</span></span> &#123;</span><br><span class="line">        observers.forEach &#123; $<span class="number">0.1</span>(event) &#125;</span><br><span class="line">        latestEvent = event</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribeEvent</span><span class="params">(perform block: @escaping <span class="params">(Event)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> uuid = <span class="type">UUID</span>().uuidString</span><br><span class="line">        observers.append((uuid, block))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> e = latestEvent &#123; block(e) &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span> &#123; [uuid] <span class="keyword">in</span> <span class="keyword">self</span>.observers.removeAll(<span class="keyword">where</span>: &#123; $<span class="number">0.0</span> == uuid &#125;) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>subscribeEvent</code> 方法我们可以注册订阅 <code>Observation</code> 的事件，每次注册订阅之后我们将传入的 <code>block</code> 保存到 <code>observers</code> 当中，我们给每一个 <code>block</code> 一个 UUID，这样我们就能够在 <code>dispose</code> 的时候准确的删掉不需要的 <code>block</code>。</p>
<p>其实更多的时候，我们才不在乎什么错误！所以可以加上这个么一个方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(onNext: @escaping <span class="params">(V)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subscribeEvent &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .next(v) = event &#123; onNext(v) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉不错。现在只剩下一个问题了，我们要如何创建一个 <code>Observation&lt;V&gt;</code> 呢？不妨再用 KVO 套一下。要生成一个监听 KVO 的 <code>Observation&lt;V&gt;</code>，我们就需要把 <code>Observation&lt;V&gt;</code> 订阅以及取消订阅 KVO 的逻辑教导给 <code>Observation&lt;V&gt;</code>。我们可以在初始化的时候进行这个步骤：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(observeBlock: (<span class="type">Observation</span>) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">    observeBlock(<span class="keyword">self</span>).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把 KVO 订阅写成这样了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">observe</span>&lt;V&gt;<span class="params">(<span class="number">_</span> keyPath: KeyPath&lt;<span class="keyword">Self</span>, V&gt;)</span></span> -&gt; <span class="type">Observation</span>&lt;<span class="type">V</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(keyPath) &#123; new, <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            observation.action(.next(new))</span><br><span class="line">        &#125; <span class="comment">// 一个 Disposable &#123; keyValueObservation.invalidate() &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化的过程中，<code>observationBlock</code> 会被调用并生成一个 <code>Disposable</code>，一旦 KVO 触发，<code>Observation</code> 就会接收到一个新值事件，而这个事件则会继续传递给 <code>Observation</code> 的观察者们。<code>Disposable</code> 有 <code>Observation</code> 负责管理，这样子一旦 <code>Observation</code> 被释放，对应的 KVO 订阅也会被释放。</p>
<p>但这里还有一个问题，在 <code>observeBlock</code> 中我们传入了 <code>Observation</code> 自身，而它在 block 内部又被 <code>subscribe</code> 的 block 给捕获了，如此产生的 <code>Disposable</code> 又返回给了 <code>Observation</code> 自己持有。铛铛铛，引用循环出现了。为了跳出这个圈，我们可以在 <code>subscribe</code> 的时候弱捕获 <code>Observation</code>，但这样很容易犯错，所以可以选择写一个 Wrapper 包住它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakObservation</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> observation: <span class="type">Observation</span>&lt;<span class="type">V</span>&gt;?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(observeBlock: (<span class="type">WeakObservation</span>) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">    observeBlock(<span class="type">WeakObservation</span>(<span class="keyword">self</span>)).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来就清晰多了。</p>
<p>首先要做的是给 <code>Emitter</code> 和 <code>Observable</code> 加上一个产生 <code>Observation</code> 的方法。我们大可以参考 <code>Observation</code> 的实现方式，将所有对它们的订阅行为储存起来。它们在这个阶段大体相同，所以我给了他们一个爸爸 <code>Notifier&lt;V&gt;</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notifier</span>&lt;<span class="title">V</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ObserverBlock</span> = (<span class="type">Observation</span>&lt;<span class="type">V</span>&gt;.<span class="type">Event</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Observer</span> = (<span class="type">String</span>, <span class="type">ObserverBlock</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> observers = [<span class="type">Observer</span>]()</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> latestEvent: <span class="type">Observation</span>&lt;<span class="type">V</span>&gt;.<span class="type">Event?</span> = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(<span class="number">_</span> event: Observation&lt;V&gt;.Event)</span></span> &#123;</span><br><span class="line">        latestEvent = event</span><br><span class="line">        observers.forEach &#123; $<span class="number">0.1</span>(event) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">(<span class="number">_</span> block: @escaping ObserverBlock)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> uuid = <span class="type">UUID</span>().uuidString</span><br><span class="line">        observers.append((uuid, block))</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>, uuid] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">self</span>.observers.removeAll(<span class="keyword">where</span>: &#123; $<span class="number">0.0</span> == uuid &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">()</span></span> -&gt; <span class="type">Observation</span>&lt;<span class="type">V</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.main</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> e = <span class="keyword">self</span>.latestEvent &#123; </span><br><span class="line">                    queue.safeAsync &#123; observation.action(e) &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">self</span>.addObserver &#123; event <span class="keyword">in</span></span><br><span class="line">                    queue.safeAsync &#123; observation.action(event) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要两个儿子在合适的时候调用 <code>notify</code> 方法就行了。至此我们的掷骰子程序就能用了！</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>但我们又怎么能就此满足，如果去看一些响应式的代码，会发现有很多将一个 <code>Observation</code> 转换为另一个 <code>Observation</code> 的代码……好吧，那我们也要有。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">viewModel.num.observe()</span><br><span class="line">    .ignoreLatest()</span><br><span class="line">    .<span class="built_in">map</span>(<span class="type">String</span>.<span class="keyword">init</span>)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">&quot;!!!&quot;</span> &#125;</span><br><span class="line">    .bind(to: textField, at: \.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>幸亏目前的实现让我们能够很简单地实现这个功能，我们只需要在原有的 <code>Observation</code> 上创建新的 <code>Observation</code> 就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;M&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(V)</span></span></span> -&gt; <span class="type">M</span>) -&gt; <span class="type">Observation</span>&lt;<span class="type">M</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observation</span>&lt;<span class="type">M</span>&gt; &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.subscribeEvent &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .next(v): observation.action(.next(transform(v)))</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> .failure(e): observation.action(.failure(e))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而更多类型的操作符都能通过同样的方式实现，就不再累述了。</p>
<h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>不知道有没有人和我一样不喜欢 <code>UIControl.addTarget</code>。要让 <code>UIControl</code> 支持上述的响应式，需要首先给它一个 <code>subscribe</code> 方法让它返回一个 <code>Disposable</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetAction</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> block: () -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(action: @escaping () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.block = action</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">performAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(<span class="number">_</span> event: UIControl.Event, block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> targetAction = <span class="type">TargetAction</span>(action: block)</span><br><span class="line">    addTarget(targetAction, action: #selector(<span class="type">TargetAction</span>.performAction), <span class="keyword">for</span>: event)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposable</span> &#123; <span class="number">_</span> = targetAction &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要一个叫做 <code>TargetAction</code> 的类充当中间人，它将会把我们传入的 block 存起来，并在一个标记为 <code>@objc</code> 的方法中调用，这样一来在这个方法当中我们就不需要像以前那样把真正的 subscriber 传进来了。有了这个方法之后，我们就能够创建 <code>observe</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">observe</span><span class="params">(<span class="number">_</span> event: UIControl.Event)</span></span> -&gt; <span class="type">Observation</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observation</span> &#123; observation <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(event) &#123; observation.action(.next(())) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些 <code>UIControl</code> 的变量并不支持 KVO，比如说 <code>UITextField.text</code>，我们会需要监听它的 <code>.editingChanged</code> 来感知这个值的变化，为了方便使用，我们可以再增加一个方法返回某个 keyPath 的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">textField.observe(.editingChanged, take: \.text)</span><br><span class="line">    .subscribe &#123; viewModel.search($<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>爽。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后我们只需要在 Podfile 里加入 RxSwift，然后把上面写的代码删掉，就能愉快地 Reactive Programming 了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/avatar-one-punch-man-2019/" class="prev">← 上一篇</a><a href="/2019/create-complicated-nested-scrollviews-with-nonscrollview/" class="next">下一篇 →</a></div><div id="container"></div><div id="disqus_thread"></div><script>var disqus_shortname = 'intii-com';
var disqus_identifier = '2019/write-code-not-that-reactively/';
var disqus_title = '稍微有点响应式编程';
var disqus_url = 'http://intii.com/2019/write-code-not-that-reactively/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//intii-com.disqus.com/count.js" async></script><div class="copyright"><p>© 2012 - 2020, handcrafted under ☁︎ in the city of knockoffs.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create',"UA-17603222-1",'auto');ga('send','pageview');</script></body></html>